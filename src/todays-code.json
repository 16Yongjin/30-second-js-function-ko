["// initialize2DArray\n// 지정된 폭과 높이 및 값의 2D 배열을 초기화합니다.\n// \n// Array.map()을 사용하여 h 행을 생성합니다. 각 행은 value로 초기화되는 크기 w의 새로운 배열입니다. 값이 제공되지 않으면, 기본값은 null입니다.\n\nconst initialize2DArray = (w, h, val = null) =>\n  Array.from({ length: h }).map(() => Array.from({ length: w }).fill(val));\n\n// 예시\ninitialize2DArray(2, 2, 0); // [[0,0], [0,0]]","// zip\n// 원래 배열의 위치를 기반으로 그룹화 된 요소 배열을 만듭니다.\n// \n// Math.max.apply()를 사용하여 인수에서 가장 긴 배열을 가져옵니다.\n// 해당 길이의 배열을 반환 값으로 만들고 Array.from()을 map 함수와 함께 사용하여 그룹화 된 요소의 배열을 만듭니다.\n// 인수 배열의 길이가 다른 경우 값을 찾을 수없는 경우 undefined가 사용됩니다.\n\nconst zip = (...arrays) => {\n  const maxLength = Math.max(...arrays.map(x => x.length));\n  return Array.from({ length: maxLength }).map((_, i) => {\n    return Array.from({ length: arrays.length }, (_, k) => arrays[k][i]);\n  });\n};\n\n// 예시\nzip(['a', 'b'], [1, 2], [true, false]); // [['a', 1, true], ['b', 2, false]]\nzip(['a'], [1, 2], [true, false]); // [['a', 1, true], [undefined, 2, false]]","// extendHex\n// 3 자리 컬러 코드를 6 자리 컬러 코드로 확장합니다.\n// \n// Array.map(), String.split() 및 Array.join()을 사용하여 매핑 된 배열을 결합하여 3 자리 RGB 표기 16 진수 색상 코드를 6 자리 양식으로 변환합니다.\n// Array.slice()는 한 번 추가되었으므로 start에서 #을 제거하는 데 사용됩니다.\n\nconst extendHex = shortHex =>\n  '#' +\n  shortHex\n    .slice(shortHex.startsWith('#') ? 1 : 0)\n    .split('')\n    .map(x => x + x)\n    .join('');\n\n// 예시\nextendHex('#03f'); // '#0033ff'\nextendHex('05a'); // '#0055aa'","// lowercaseKeys\n// 모든 키가 소문자 인 지정된 객체에서 새 객체를 만듭니다.\n// \n// Object.keys() 및 Array.reduce()를 사용하여 지정된 객체에서 새 객체를 만듭니다.\n// String.toLowerCase()를 사용하여 원본 객체의 각 키를 소문자로 변환합니다.\n\nconst lowercaseKeys = obj =>\n  Object.keys(obj).reduce((acc, key) => {\n    acc[key.toLowerCase()] = obj[key];\n    return acc;\n  }, {});\n\n// 예시\nconst myObj = { Name: 'Adam', sUrnAME: 'Smith' };\nconst myObjLower = lowercaseKeys(myObj); // {name: 'Adam', surname: 'Smith'};","// decapitalize\n// 문자열의 첫 문자를 decapitalizes.\n// \n// 배열 소멸 및 String.toLowerCase()를 사용하여 첫 번째 문자의 소문자를 제거하고 첫 번째 문자 다음에 문자 배열을 가져오고 Array.join ( '')을 사용하여 문자열을 다시 문자열로 만듭니다.\n// upperRest 매개 변수를 생략하여 나머지 문자열을 그대로 유지하거나 true로 설정하여 대문자로 변환하십시오.\n\nconst decapitalize = ([first, ...rest], upperRest = false) =>\n  first.toLowerCase() + (upperRest ? rest.join('').toUpperCase() : rest.join(''));\n\n// 예시\ndecapitalize('FooBar'); // 'fooBar'\ndecapitalize('FooBar', true); // 'fOOBAR'","// inRange\n// 지정된 수치가 지정된 범위 내에 있을지 어떨지를 판정합니다.\n// \n// 지정된 숫자가 지정된 범위에 있는지 확인하려면 산술 비교를 사용하십시오.\n// 두 번째 매개 변수 인 end가 지정되지 않은 경우 범위는 0부터 시작할 것으로 간주됩니다.\n\nconst inRange = (n, start, end = null) => {\n  if (end && start > end) end = [start, (start = end)][0];\n  return end == null ? n >= 0 && n < start : n >= start && n < end;\n};\n\n// 예시\ninRange(3, 2, 5); // true\ninRange(3, 4); // true\ninRange(2, 3, 5); // false\ninrange(3, 2); // false","// bind\n// 지정된 컨텍스트로 fn을 호출하는 함수를 작성합니다. 선택적으로 인수의 시작 부분에 추가 매개 변수를 추가합니다.\n// \n// Function.apply()를 사용하여 fn에 주어진 컨텍스트를 적용하는 함수를 반환하십시오.\n// Array.concat()을 사용하여 제공된 매개 변수를 인수 앞에 추가하십시오.\n\nconst bind = (fn, context, ...boundArgs) => (...args) => fn.apply(context, [...boundArgs, ...args]);\n\n// 예시\nfunction greet(greeting, punctuation) {\n  return greeting + ' ' + this.user + punctuation;\n}\nconst freddy = { user: 'fred' };\nconst freddyBound = bind(greet, freddy);\nconsole.log(freddyBound('hi', '!')); // 'hi fred!'","// reduceWhich\n// 제공된 함수를 적용하여 비교 규칙을 설정 한 후 배열의 최소 / 최대 값을 반환합니다.\n// \n// Array.reduce()를 comparator 함수와 함께 사용하여 배열에서 적절한 요소를 가져옵니다.\n// 두 번째 매개 변수 인 comparator를 생략하여 배열의 최소 요소를 반환하는 기본 매개 변수를 사용할 수 있습니다.\n\nconst reduceWhich = (arr, comparator = (a, b) => a - b) =>\n  arr.reduce((a, b) => (comparator(a, b) >= 0 ? b : a));\n\n// 예시\nreduceWhich([1, 3, 2]); // 1\nreduceWhich([1, 3, 2], (a, b) => b - a); // 3\nreduceWhich(\n  [{ name: 'Tom', age: 12 }, { name: 'Jack', age: 18 }, { name: 'Lucy', age: 9 }],\n  (a, b) => a.age - b.age\n); // {name: \"Lucy\", age: 9}","// functionName\n// 함수의 이름을 기록합니다.\n// \n// 메소드의 이름을 콘솔의 디버그 채널에 기록하려면 console.debug()와 전달 된 메소드의 name 속성을 사용하십시오.\n\nconst functionName = fn => (console.debug(fn.name), fn);\n\n// 예시\nfunctionName(Math.max); // max (logged in debug channel of console)","// stripHTMLTags\n// 문자열에서 HTML / XML 태그를 제거합니다.\n// \n// 문자열에서 HTML / XML 태그를 제거하려면 일반 표현식을 사용하십시오.\n\nconst stripHTMLTags = str => str.replace(/<[^>]*>/g, '');\n\n// 예시\nstripHTMLTags('<p><em>lorem</em> <strong>ipsum</strong></p>'); // 'lorem ipsum'","// median\n// 숫자 배열의 중앙값을 반환합니다.\n// \n// 배열의 가운데를 찾고 Array.sort()를 사용하여 값을 정렬합니다.\n// 길이가 홀수 인 경우 중간 지점의 수를 반환하고 그렇지 않으면 중간 두 숫자의 평균을 반환합니다.\n\nconst median = arr => {\n  const mid = Math.floor(arr.length / 2),\n    nums = [...arr].sort((a, b) => a - b);\n  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\n\n// 예시\nmedian([5, 6, 50, 1, -5]); // 5","// partial\n// 수신 한 인수 앞에 partial이있는 fn을 호출하는 함수를 작성합니다.\n// \n// 확산 연산자 (...)를 사용하여 fn의 인수 목록에 부분을 추가합니다.\n\nconst partial = (fn, ...partials) => (...args) => fn(...partials, ...args);\n\n// 예시\nconst greet = (greeting, name) => greeting + ' ' + name + '!';\nconst greetHello = partial(greet, 'Hello');\ngreetHello('John'); // 'Hello John!'","// isPrime\n// 제공된 정수가 소수인지 검사합니다.\n// \n// 2에서 주어진 숫자의 제곱근까지 숫자를 확인하십시오.\n// 숫자가 2보다 작은 경우를 제외하고는 지정된 숫자를 나눌 수 있으면 false를 반환하고 그렇지 않으면 true를 반환합니다.\n\nconst isPrime = num => {\n  const boundary = Math.floor(Math.sqrt(num));\n  for (var i = 2; i <= boundary; i++) if (num % i === 0) return false;\n  return num >= 2;\n};\n\n// 예시\nisPrime(11); // true","// pickBy\n// 주어진 함수가 진리를 반환하는 속성으로 구성된 객체를 만듭니다. 이 함수는 (value, key) 두 개의 인수로 호출됩니다.\n// \n// Object.keys (obj) 및 Array.filter()를 사용하여 fn이 false 값을 반환하는 키를 제거합니다.\n// Array.reduce()를 사용하여 필터링 된 키를 해당 키 - 값 쌍을 가진 객체로 다시 변환합니다.\n\nconst pickBy = (obj, fn) =>\n  Object.keys(obj)\n    .filter(k => fn(obj[k], k))\n    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});\n\n// 예시\npickBy({ a: 1, b: '2', c: 3 }, x => typeof x === 'number'); // { 'a': 1, 'c': 3 }","// mapKeys\n// 각 키에 대해 제공된 함수를 실행하고 제공된 객체와 동일한 값을 실행하여 생성 된 키가있는 객체를 만듭니다.\n// \n// Object.keys (obj)를 사용하여 객체 키를 반복합니다.\n// Array.reduce()를 사용하여 fn을 사용하여 동일한 값과 매핑 된 키를 사용하여 새 객체를 만듭니다.\n\nconst mapKeys = (obj, fn) =>\n  Object.keys(obj).reduce((acc, k) => {\n    acc[fn(obj[k], k, obj)] = obj[k];\n    return acc;\n  }, {});\n\n// 예시\nmapKeys({ a: 1, b: 2 }, (val, key) => key + val); // { a1: 1, b2: 2 }","// gcd\n// 두 개 이상의 숫자 / 배열 사이의 최대 공약수를 계산합니다.\n// \n// 내부 _gcd 함수는 재귀를 사용합니다.\n// 기본 경우는 y가 0 일 때입니다.이 경우 x를 반환합니다.\n// 그렇지 않으면 y의 GCD와 나눗셈의 나머지 x / y를 반환합니다.\n\nconst gcd = (...arr) => {\n  const _gcd = (x, y) => (!y ? x : gcd(y, x % y));\n  return [...arr].reduce((a, b) => _gcd(a, b));\n};\n\n// 예시\ngcd(8, 36); // 4\ngcd(...[12, 8, 32]); // 4","// unfold\n// 반복자 함수와 초기 시드 값을 사용하여 배열을 만듭니다.\n// \n// while 루프와 Array.push()를 사용하여 false를 반환 할 때까지 함수를 반복적으로 호출합니다.\n// iterator 함수는 하나의 인수 (seed)를 받아들이고 두 요소 ([value, nextSeed])가있는 배열을 반환하거나 종료하려면 false를 반환해야합니다.\n\nconst unfold = (fn, seed) => {\n  let result = [],\n    val = [null, seed];\n  while ((val = fn(val[1]))) result.push(val[0]);\n  return result;\n};\n\n// 예시\nvar f = n => (n > 50 ? false : [-n, n + 10]);\nunfold(f, 10); // [-10, -20, -30, -40, -50]","// reverseString\n// 문자열을 반대로합니다.\n// \n// 스프레드 연산자 (...) 및 Array.reverse()를 사용하면 문자열의 문자 순서를 바꿀 수 있습니다.\n// 문자열을 결합하여 String.join ( '')을 사용하여 문자열을 가져옵니다.\n\nconst reverseString = str => [...str].reverse().join('');\n\n// 예시\nreverseString('foobar'); // 'raboof'","// reject\n// Array.filter()와 마찬가지로 조건부 및 배열을 사용하지만 pred (x) === false 인 경우에만 x를 유지합니다.\n\nconst reject = (pred, array) => array.filter((...args) => !pred(...args));\n\n// 예시\nreject(x => x % 2 === 0, [1, 2, 3, 4, 5]); // [1, 3, 5]\nreject(word => word.length > 4, ['Apple', 'Pear', 'Kiwi', 'Banana']); // ['Pear', 'Kiwi']","// permutations\n// ⚠️ ** WARNING ** :이 함수의 실행 시간은 각 배열 요소에 따라 기하 급수적으로 증가합니다. 8-10 항목을 초과하는 항목은 브라우저에서 모든 다른 조합을 해결하려고 할 때 중단됩니다.\n// \n// 배열 요소의 모든 순열을 생성합니다 (중복 포함).\n// \n// 재귀를 사용하십시오.\n// 주어진 배열의 각 요소에 대해 나머지 요소에 대한 모든 부분 순열을 작성하십시오.\n// Array.map()을 사용하여 요소를 각 부분 순열과 결합한 다음 Array.reduce()를 사용하여 모든 순열을 하나의 배열로 결합합니다.\n// 기본 케이스는 배열 길이가 2 또는 1 인 경우입니다.\n\nconst permutations = arr => {\n  if (arr.length <= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr;\n  return arr.reduce(\n    (acc, item, i) =>\n      acc.concat(\n        permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val => [item, ...val])\n      ),\n    []\n  );\n};\n\n// 예시\npermutations([1, 33, 5]); // [ [ 1, 33, 5 ], [ 1, 5, 33 ], [ 33, 1, 5 ], [ 33, 5, 1 ], [ 5, 1, 33 ], [ 5, 33, 1 ] ]","// transform\n// 누적 기 및 객체의 각 키에 대해 함수를 적용합니다 (왼쪽에서 오른쪽으로).\n// \n// Object.keys (obj)를 사용하여 객체의 각 키 (Array.reduce())를 반복하여 지정된 누적기에 대해 지정된 함수를 적용합니다.\n\nconst transform = (obj, fn, acc) => Object.keys(obj).reduce((a, k) => fn(a, obj[k], k, obj), acc);\n\n// 예시\ntransform(\n  { a: 1, b: 2, c: 1 },\n  (r, v, k) => {\n    (r[v] || (r[v] = [])).push(k);\n    return r;\n  },\n  {}\n); // { '1': ['a', 'c'], '2': ['b'] }","// countBy\n// 지정된 함수를 기반으로 배열의 요소를 그룹화하고 각 그룹의 요소 수를 반환합니다.\n// \n// Array.map()을 사용하여 배열 값을 함수 또는 속성 이름에 매핑합니다.\n// Array.reduce()를 사용하여 매핑 된 결과에서 키가 생성되는 객체를 만듭니다.\n\nconst countBy = (arr, fn) =>\n  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val, i) => {\n    acc[val] = (acc[val] || 0) + 1;\n    return acc;\n  }, {});\n\n// 예시\ncountBy([6.1, 4.2, 6.3], Math.floor); // {4: 1, 6: 2}\ncountBy(['one', 'two', 'three'], 'length'); // {3: 2, 5: 1}","// isPlainObject\n// 제공된 값이 Object 생성자에 의해 생성 된 객체인지 확인합니다.\n// \n// 제공된 값이 true인지 확인하고, typeof를 사용하여 객체인지 확인하고, Object.constructor를 사용하여 생성자가 Object와 같은지 확인하십시오.\n\nconst isPlainObject = val => !!val && typeof val === 'object' && val.constructor === Object;\n\n// 예시\nisPlainObject({ a: 1 }); // true\nisPlainObject(new Map()); // false","// randomIntegerInRange\n// 지정된 범위의 임의의 정수를 반환합니다.\n// \n// Math.random()을 사용하여 난수를 생성하고 Math.floor()를 사용하여 원하는 범위에 매핑하여 정수로 만듭니다.\n\nconst randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n// 예시\nrandomIntegerInRange(0, 5); // 2","// takeRight\n// 끝에서 n 개 요소가 제거 된 배열을 반환합니다.\n// \n// Array.slice()를 사용하여 끝에있는 n 개의 요소가있는 배열 조각을 만듭니다.\n\nconst takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);\n\n// 예시\ntakeRight([1, 2, 3], 2); // [ 2, 3 ]\ntakeRight([1, 2, 3]); // [3]","// JSONtoCSV ![advanced](/advanced.svg)\n// 개체 배열을 지정된 열만 포함하는 쉼표로 구분 된 값 (CSV) 문자열로 변환합니다.\n// \n// Array.join (demiliter)을 사용하여 열의 모든 이름을 결합하여 첫 번째 행을 만듭니다.\n// Array.map() 및 Array.reduce()를 사용하여 존재하지 않는 값을 빈 문자열로 대체하고 열의 값만 매핑하여 각 객체에 대한 행을 만듭니다.\n// Array.join ( '\\ n')을 사용하여 모든 행을 문자열로 결합합니다.\n// 세 번째 인수 인 delimiter를 생략하고,의 기본 구분 기호를 사용하십시오.\n\nconst JSONtoCSV = (arr, columns, delimiter = ',') =>\n  [\n    columns.join(delimiter),\n    ...arr.map(obj =>\n      columns.reduce(\n        (acc, key) => `${acc}${!acc.length ? '' : delimiter}\"${!obj[key] ? '' : obj[key]}\"`,\n        ''\n      )\n    )\n  ].join('\\n');\n\n// 예시\nJSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b']); // 'a,b\\n\"1\",\"2\"\\n\"3\",\"4\"\\n\"6\",\"\"\\n\"\",\"7\"'\nJSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b'], ';'); // 'a;b\\n\"1\";\"2\"\\n\"3\";\"4\"\\n\"6\";\"\"\\n\"\";\"7\"'","// parseCookie\n// HTTP 쿠키 헤더 문자열을 구문 분석하고 모든 쿠키 이름 - 값 쌍의 객체를 반환합니다.\n// \n// String.split ( ';')를 사용하여 키 - 값 쌍을 서로 분리하십시오.\n// Array.map() 및 String.split ( '=')을 사용하여 각 쌍의 값에서 키를 구분하십시오.\n// Array.reduce() 및 decodeURIComponent()를 사용하여 모든 키 - 값 쌍이있는 객체를 만듭니다.\n\nconst parseCookie = str =>\n  str\n    .split(';')\n    .map(v => v.split('='))\n    .reduce((acc, v) => {\n      acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());\n      return acc;\n    }, {});\n\n// 예시\nparseCookie('foo=bar; equation=E%3Dmc%5E2'); // { foo: 'bar', equation: 'E=mc^2' }","// UUIDGeneratorBrowser\n// 브라우저에서 UUID를 생성합니다.\n// \n// crypto API를 사용하여 [RFC4122] (https://www.ietf.org/rfc/rfc4122.txt) 버전 4와 호환되는 UUID를 생성하십시오.\n\nconst UUIDGeneratorBrowser = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n  );\n\n// 예시\nUUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'","// hide\n// 지정된 모든 요소를 숨 깁니다.\n// \n// spread 연산자 (...) 및 Array.forEach()를 사용하여 지정된 각 요소에 display : none을 적용합니다.\n\nconst hide = (...el) => [...el].forEach(e => (e.style.display = 'none'));\n\n// 예시\nhide(...document.querySelectorAll('img')); // Hides all <img> elements on the page","// allEqual\n// 모든 요소가 같은지 확인\n// \n// Array.every()를 사용하여 배열의 모든 요소가 첫 번째 요소와 동일한 지 확인합니다.\n\nconst allEqual = arr => arr.every(val => val === arr[0]);\n\n// 예시\nallEqual([1, 2, 3, 4, 5, 6]); // false\nallEqual([1, 1, 1, 1]); // true","// randomIntArrayInRange\n// 지정된 범위에있는 n 개의 임의의 정수 배열을 반환합니다.\n// \n// Array.from()을 사용하여 특정 길이 Math.random()의 빈 배열을 만들어 임의의 숫자를 생성하고 Math.floor()를 사용하여 원하는 범위에 매핑합니다.\n\nconst randomIntArrayInRange = (min, max, n = 1) =>\n  Array.from({ length: n }, () => Math.floor(Math.random() * (max - min + 1)) + min);\n\n// 예시\nrandomIntArrayInRange(12, 35, 10); // [ 34, 14, 27, 17, 30, 27, 20, 26, 21, 14 ]","// isUndefined\n// 지정된 값이 정의되지 않은 경우 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// 완전 항등 연산자를 사용하여 값과 val이 undefined와 같은지 확인하십시오.\n\nconst isUndefined = val => val === undefined;\n\n// 예시\nisUndefined(undefined); // true","// toSnakeCase\n// 문자열을 뱀 케이스로 변환합니다.\n// \n// 문자열을 단어로 분리하고 정규 표현식을 사용하여 _을 구분 기호로 추가하여 결합하십시오.\n\nconst toSnakeCase = str =>\n  str &&\n  str\n    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n    .map(x => x.toLowerCase())\n    .join('_');\n\n// 예시\ntoSnakeCase('camelCase'); // 'camel_case'\ntoSnakeCase('some text'); // 'some_text'\ntoSnakeCase('some-mixed_string With spaces_underscores-and-hyphens'); // 'some_mixed_string_with_spaces_underscores_and_hyphens'\ntoSnakeCase('AllThe-small Things'); // \"all_the_smal_things\"\ntoSnakeCase('IAmListeningToFMWhileLoadingDifferentURLOnMyBrowserAndAlsoEditingSomeXMLAndHTML'); // \"i_am_listening_to_fm_while_loading_different_url_on_my_browser_and_also_editing_some_xml_and_html\"","// everyNth\n// 배열의 모든 n 번째 요소를 반환합니다.\n// \n// Array.filter()를 사용하여 지정된 배열의 모든 n 번째 요소를 포함하는 새 배열을 만듭니다.\n\nconst everyNth = (arr, nth) => arr.filter((e, i) => i % nth === nth - 1);\n\n// 예시\neveryNth([1, 2, 3, 4, 5, 6], 2); // [ 2, 4, 6 ]","// composeRight\n// 왼쪽에서 오른쪽으로 기능을 구성합니다.\n// \n// 왼쪽에서 오른쪽으로 기능을 구성하려면 Array.reduce()를 사용하십시오.\n// 첫 번째 (가장 왼쪽) 함수는 하나 이상의 인수를 허용 할 수 있습니다. 나머지 함수는 단항이어야합니다.\n\nconst composeRight = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));\n\n// 예시\nconst add = (x, y) => x + y;\nconst square = x => x * x;\nconst addAndSquare = composeRight(add, square);\naddAndSquare(1, 2); // 9","// isPrimitive\n// 건네받은 값이 프리미티브 (primitive)인지 어떤지를 판정하는 boolean를 돌려줍니다.\n// \n// 프리미티브가 아닌 유형 문자열의 배열에 대해 Array.includes()를 사용합니다.\n// typeof를 사용하여 유형을 제공합니다.\n// typeof null은 'object'로 평가되므로 직접 비교해야합니다.\n\nconst isPrimitive = val => !['object', 'function'].includes(typeof val) || val === null;\n\n// 예시\nisPrimitive(null); // true\nisPrimitive(50); // true\nisPrimitive('Hello!'); // true\nisPrimitive(false); // true\nisPrimitive(Symbol()); // true\nisPrimitive([]); // false","// sortedLastIndexBy\n// 제공된 iterator 함수를 기반으로 정렬 순서를 유지하기 위해 배열에 값을 삽입해야하는 가장 높은 인덱스를 반환합니다.\n// \n// 배열이 내림차순으로 정렬되는지 (느슨하게) 확인하십시오.\n// Array.map()을 사용하여 반복자 함수를 배열의 모든 요소에 적용합니다.\n// Array.reverse() 및 Array.findIndex()를 사용하여 제공된 반복기 함수를 기반으로 요소를 삽입해야하는 적절한 마지막 인덱스를 찾습니다.\n\nconst sortedLastIndexBy = (arr, n, fn) => {\n  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);\n  const val = fn(n);\n  const index = arr\n    .map(fn)\n    .reverse()\n    .findIndex(el => (isDescending ? val <= el : val >= el));\n  return index === -1 ? 0 : arr.length - index;\n};\n\n// 예시\nsortedLastIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 1","// deepClone\n// 객체의 딥 클론을 작성합니다.\n// \n// 재귀를 사용하십시오.\n// Object.assign() 및 빈 객체 ({})를 사용하여 원본의 얕은 복제본을 만듭니다.\n// Object.keys() 및 Array.forEach()를 사용하여 어떤 키 - 값 쌍을 깊이 복제해야하는지 결정합니다.\n\nconst deepClone = obj => {\n  let clone = Object.assign({}, obj);\n  Object.keys(clone).forEach(\n    key => (clone[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key])\n  );\n  return Array.isArray(obj) ? (clone.length = obj.length) && Array.from(clone) : clone;\n};\n\n// 예시\nconst a = { foo: 'bar', obj: { a: 1, b: 2 } };\nconst b = deepClone(a); // a !== b, a.obj !== b.obj","// nest\n// 서로 연결된 객체의 편평한 배열이 주어지면, 객체를 반복적으로 중첩합니다.\n// reddit.com에서와 같이 주석을 중첩하는 데 유용합니다.\n// \n// 재귀를 사용하십시오.\n// Array.filter()를 사용하여 id가 링크와 일치하는 항목을 필터링 한 다음 Array.map()을 사용하여 각 항목을 현재 아이의 항목을 기반으로 항목을 재귀 적으로 중첩하는 children 속성이있는 새 객체에 매핑합니다. 목.\n// 두 번째 인자 인 id가 객체가 다른 객체 (즉, 최상위 객체)에 링크되어 있지 않음을 나타내는 null로 기본 설정하지 않습니다.\n// 세 번째 인자 인 link를 생략하면 'parent_id'가 id로 다른 객체에 링크하는 기본 속성으로 사용됩니다.\n\nconst nest = (items, id = null, link = 'parent_id') =>\n  items\n    .filter(item => item[link] === id)\n    .map(item => ({ ...item, children: nest(items, item.id) }));\n\n// 예시\n// One top level comment\nconst comments = [\n  { id: 1, parent_id: null },\n  { id: 2, parent_id: 1 },\n  { id: 3, parent_id: 1 },\n  { id: 4, parent_id: 2 },\n  { id: 5, parent_id: 4 }\n];\nconst nestedComments = nest(comments); // [{ id: 1, parent_id: null, children: [...] }]","// matches\n// 두 객체를 비교하여 첫 번째 객체가 두 번째 객체와 동일한 속성 값을 포함하는지 확인합니다.\n// \n// Object.keys (source)를 사용하여 두 번째 객체의 모든 키를 얻은 다음 Array.every(), Object.hasOwnProperty() 및 엄격한 비교를 수행하여 모든 키가 첫 번째 객체에 존재하고 동일한 값을 갖는지 확인합니다.\n\nconst matches = (obj, source) =>\n  Object.keys(source).every(key => obj.hasOwnProperty(key) && obj[key] === source[key]);\n\n// 예시\nmatches({ age: 25, hair: 'long', beard: true }, { hair: 'long', beard: true }); // true\nmatches({ hair: 'long', beard: true }, { age: 25, hair: 'long', beard: true }); // false","// matchesWith\n// 두 객체를 비교하여 첫 번째 객체가 제공된 함수를 기반으로 두 번째 객체와 동일한 속성 값을 포함하는지 확인합니다.\n// \n// Object.keys (source)를 사용하여 두 번째 객체의 모든 키를 가져온 다음 Array.every(), Object.hasOwnProperty() 및 제공된 함수를 사용하여 모든 키가 첫 번째 객체에 존재하는지 확인하고 동일한 값을 갖는지 확인합니다.\n// 함수가 제공되지 않으면 항등 연산자를 사용하여 값을 비교합니다.\n\nconst matchesWith = (obj, source, fn) =>\n  Object.keys(source).every(\n    key =>\n      obj.hasOwnProperty(key) && fn\n        ? fn(obj[key], source[key], key, obj, source)\n        : obj[key] == source[key]\n  );\n\n// 예시\nconst isGreeting = val => /^h(?:i|ello)$/.test(val);\nmatchesWith(\n  { greeting: 'hello' },\n  { greeting: 'hi' },\n  (oV, sV) => isGreeting(oV) && isGreeting(sV)\n); // true","// isNumber\n// 지정된 인수가 수치 일지 어떨지를 판정합니다.\n// \n// 값이 숫자 프리미티브로 분류되는지 확인하려면 typeof를 사용하십시오.\n\nconst isNumber = val => typeof val === 'number';\n\n// 예시\nisNumber('1'); // false\nisNumber(1); // true","// shallowClone\n// 객체의 얕은 복제를 만듭니다.\n// \n// Object.assign() 및 빈 객체 ({})를 사용하여 원본의 얕은 복제본을 만듭니다.\n\nconst shallowClone = obj => Object.assign({}, obj);\n\n// 예시\nconst a = { x: true, y: 1 };\nconst b = shallowClone(a); // a !== b","// intersection\n// 두 배열에있는 요소의 목록을 반환합니다.\n// \n// b에서 Set을 만든 다음 a에 Array.filter()를 사용하여 b에 포함 된 값만 유지합니다.\n\nconst intersection = (a, b) => {\n  const s = new Set(b);\n  return a.filter(x => s.has(x));\n};\n\n// 예시\nintersection([1, 2, 3], [4, 3, 2]); // [2,3]","// sample\n// 배열에서 임의의 요소를 반환합니다.\n// \n// Math.random()을 사용하여 난수를 생성하고 길이를 곱한 다음 Math.floor()를 사용하여 가장 가까운 정수로 반올림합니다.\n// 이 방법은 문자열에서도 작동합니다.\n\nconst sample = arr => arr[Math.floor(Math.random() * arr.length)];\n\n// 예시\nsample([3, 7, 9, 11]); // 9","// pull\n// 원래의 배열을 변경하여 지정된 값을 필터링합니다.\n// \n// Array.filter() 및 Array.includes()를 사용하여 필요하지 않은 값을 추출합니다.\n// Array.length = 0을 사용하면 길이를 0으로 재설정하고 Array.push()를 사용하여 전달 된 값을 변경하여 끌어온 값만 다시 채 웁니다.\n// \n// _ (원래 배열을 변경하지 않는 스 니펫의 경우 [없음] (#없이) 참조) _\n\nconst pull = (arr, ...args) => {\n  let argState = Array.isArray(args[0]) ? args[0] : args;\n  let pulled = arr.filter((v, i) => !argState.includes(v));\n  arr.length = 0;\n  pulled.forEach(v => arr.push(v));\n};\n\n// 예시\nlet myArray = ['a', 'b', 'c', 'a', 'b', 'c'];\npull(myArray, 'a', 'c'); // myArray = [ 'b', 'b' ]","// dig\n// 지정된 키를 기반으로 중첩 JSON 객체의 대상 값을 반환합니다.\n// \n// in 연산자를 사용하여 대상이 obj에 있는지 확인합니다.\n// 발견되면, obj [target]의 값을 반환하고 그렇지 않으면 Object.values (obj) 및 Array.reduce()를 사용하여 첫 번째 일치하는 키 / 값 쌍이 발견 될 때까지 각 중첩 객체에서 dig를 재귀 적으로 호출합니다.\n\nconst dig = (obj, target) =>\n  target in obj\n    ? obj[target]\n    : Object.values(obj).reduce((acc, val) => {\n        if (acc !== undefined) return acc;\n        if (typeof val === 'object') return dig(val, target);\n      }, undefined);\n\n// 예시\nconst data = {\n  level1: {\n    level2: {\n      level3: 'some data'\n    }\n  }\n};\ndig(data, 'level3'); // 'some data'\ndig(data, 'level4'); // undefined","// bindAll\n// 기존 메서드를 덮어 쓰면서 개체의 메서드를 개체 자체에 바인딩합니다.\n// \n// Array.forEach()를 사용하여 Function.apply()를 사용하는 함수를 반환하여 지정된 각 함수에 대해 지정된 컨텍스트 (obj)를 fn에 적용합니다.\n\nconst bindAll = (obj, ...fns) =>\n  fns.forEach(\n    fn => (\n      (f = obj[fn]),\n      (obj[fn] = function() {\n        return f.apply(obj);\n      })\n    )\n  );\n\n// 예시\nvar view = {\n  label: 'docs',\n  click: function() {\n    console.log('clicked ' + this.label);\n  }\n};\nbindAll(view, 'click');\njQuery(element).on('click', view.click); // Logs 'clicked docs' when clicked.","// dropRightWhile\n// 전달 된 함수가 true를 반환 할 때까지 배열 끝에서 요소를 제거합니다. 배열의 나머지 요소를 반환합니다.\n// \n// Array.slice()를 사용하여 배열의 루프를 반복하여 함수의 반환 값이 true가 될 때까지 배열의 마지막 요소를 삭제합니다.\n// 나머지 요소를 반환합니다.\n\nconst dropRightWhile = (arr, func) => {\n  while (arr.length > 0 && !func(arr[arr.length - 1])) arr = arr.slice(0, -1);\n  return arr;\n};\n\n// 예시\ndropRightWhile([1, 2, 3, 4], n => n < 3); // [1, 2]","// chainAsync\n// 체인 비동기 함수.\n// \n// 비동기 이벤트가 포함 된 함수 배열을 반복하면서 각 비동기 이벤트가 완료 될 때 next를 호출합니다.\n\nconst chainAsync = fns => {\n  let curr = 0;\n  const next =() => fns[curr++](next);\n  next();\n};\n\n// 예시\nchainAsync([\n  next => {\n    console.log('0 seconds');\n    setTimeout(next, 1000);\n  },\n  next => {\n    console.log('1 second');\n  }\n]);","// ary\n// 추가 인수를 무시하고 최대 n 개의 인수를 허용하는 함수를 만듭니다.\n// \n// Array.slice (0, n) 및 스프레드 연산자 (...)를 사용하여 최대 인수가 n 인 제공된 함수 fn을 호출합니다.\n\nconst ary = (fn, n) => (...args) => fn(...args.slice(0, n));\n\n// 예시\nconst firstTwoMax = ary(Math.max, 2);\n[[2, 6, 'a'], [8, 4, 6], [10]].map(x => firstTwoMax(...x)); // [6, 8, 10]","// curry\n// 함수를 카레합니다.\n// \n// 재귀를 사용하십시오.\n// 제공된 인수 (args)의 수가 충분하면 전달 된 함수 fn을 호출하십시오.\n// 그렇지 않으면 나머지 인수를 예상하는 카 트리 함수 fn을 리턴하십시오.\n// 다양한 수의 인수 (가변 인수 함수, 예 : Math.min())를 허용하는 함수를 카레하려고하는 경우 선택적으로 인수의 수를 두 번째 매개 변수 arity로 전달할 수 있습니다.\n\nconst curry = (fn, arity = fn.length, ...args) =>\n  arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);\n\n// 예시\ncurry(Math.pow)(2)(10); // 1024\ncurry(Math.min, 3)(10)(50)(2); // 2","// sortedIndex\n// 정렬 순서를 유지하기 위해 배열에 값을 삽입해야하는 가장 작은 인덱스를 반환합니다.\n// \n// 배열이 내림차순으로 정렬되는지 (느슨하게) 확인하십시오.\n// Array.findIndex()를 사용하여 요소가 삽입되어야하는 적절한 인덱스를 찾습니다.\n\nconst sortedIndex = (arr, n) => {\n  const isDescending = arr[0] > arr[arr.length - 1];\n  const index = arr.findIndex(el => (isDescending ? n >= el : n <= el));\n  return index === -1 ? arr.length : index;\n};\n\n// 예시\nsortedIndex([5, 3, 2, 1], 4); // 1\nsortedIndex([30, 50], 40); // 1","// times\n// 콜백을 n 번 반복합니다.\n// \n// Function.call()을 사용하여 fn을 n 번 또는 false를 반환 할 때까지 호출합니다.\n// 정의되지 않은 개체 (또는 비 엄격 모드에서 전역 개체)를 사용하려면 마지막 인수 인 context를 생략하십시오.\n\nconst times = (n, fn, context = undefined) => {\n  let i = 0;\n  while (fn.call(context, i) !== false && ++i < n) {}\n};\n\n// 예시\nvar output = '';\ntimes(5, i => (output += i));\nconsole.log(output); // 01234","// insertAfter\n// 지정된 요소의 끝 뒤에 HTML 문자열을 삽입합니다.\n// \n// el.insertAdjacentHTML()을 'afterend'위치로 사용하여 htmlString을 파싱하고 el의 끝 뒤에 삽입합니다.\n\nconst insertAfter = (el, htmlString) => el.insertAdjacentHTML('afterend', htmlString);\n\n// 예시\ninsertAfter(document.getElementById('myId'), '<p>after</p>'); // <div id=\"myId\">...</div> <p>after</p>","// isUpperCase\n// 문자열이 대문자인지 검사합니다.\n// \n// String.toUpperCase()를 사용하여 주어진 문자열을 대문자로 변환하고 원본과 비교하십시오.\n\nconst isUpperCase = str => str === str.toUpperCase();\n\n// 예시\nisUpperCase('ABC'); // true\nisLowerCase('A3@$'); // true\nisLowerCase('aB4'); // false","// hashNode\n// [SHA-256] (https://en.wikipedia.org/wiki/SHA-2) 알고리즘을 사용하여 값에 대한 해시를 만듭니다. 약속을 반환합니다.\n// \n// crypto API를 사용하여 주어진 값에 대한 해시를 생성하십시오.\n\nconst crypto = require('crypto');\nconst hashNode = val =>\n  new Promise(resolve =>\n    setTimeout(\n      () =>\n        resolve(\n          crypto\n            .createHash('sha256')\n            .update(val)\n            .digest('hex')\n        ),\n      0\n    )\n  );\n\n// 예시\nhashNode(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'","// debounce\n// 마지막으로 호출 된 이후 최소 ms 밀리 초가 경과 할 때까지 제공된 함수를 호출하는 것을 지연시키는 디 바운스 함수를 작성합니다.\n// \n// 디 바운스 된 함수가 호출 될 때마다 clearTimeout()을 사용하여 현재 보류중인 시간 초과를 지우고 setTimeout()을 사용하여 적어도 ms 밀리 초가 경과 할 때까지 함수를 호출하는 것을 지연시키는 새로운 시간 초과를 생성하십시오. Function.apply()를 사용하여이 컨텍스트를 함수에 적용하고 필요한 인수를 제공하십시오.\n// 두 번째 인수 인 ms를 생략하여 기본값 인 0ms로 시간 초과를 설정하십시오.\n\nconst debounce = (fn, ms = 0) => {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n// 예시\nwindow.addEventListener(\n  'resize',\n  debounce(() => {\n    console.log(window.innerWidth);\n    console.log(window.innerHeight);\n  }, 250)\n); // Will log the window dimensions at most every 250ms","// negate\n// 술어 함수를 무효화합니다.\n// \n// 술어 함수를 취해 인수에 not 연산자 (!)를 적용하십시오.\n\nconst negate = func => (...args) => !func(...args);\n\n// 예시\n[1, 2, 3, 4, 5, 6].filter(negate(n => n % 2 === 0)); // [ 1, 3, 5 ]","// words\n// 주어진 문자열을 단어 배열로 변환합니다.\n// \n// String.split()을 제공된 패턴 (기본값은 정규 표현식으로 알파가 아닌 문자열)과 함께 사용하여 문자열 배열로 변환합니다. Array.filter()를 사용하여 빈 문자열을 제거하십시오.\n// 기본 정규 표현식을 사용하려면 두 번째 인수를 생략하십시오.\n\nconst words = (str, pattern = /[^a-zA-Z-]+/) => str.split(pattern).filter(Boolean);\n\n// 예시\nwords('I love javaScript!!'); // [\"I\", \"love\", \"javaScript\"]\nwords('python, javaScript & coffee'); // [\"python\", \"javaScript\", \"coffee\"]","// isLowerCase\n// 문자열이 소문자인지 검사합니다.\n// \n// String.toLowerCase()를 사용하여 주어진 문자열을 소문자로 변환하고 원본과 비교하십시오.\n\nconst isLowerCase = str => str === str.toLowerCase();\n\n// 예시\nisLowerCase('abc'); // true\nisLowerCase('a3@$'); // true\nisLowerCase('Ab4'); // false","// getDaysDiffBetweenDates\n// 두 날짜 간의 차이 (일)를 반환합니다.\n// \n// 두 Date 객체 간의 차이 (일)를 계산합니다.\n\nconst getDaysDiffBetweenDates = (dateInitial, dateFinal) =>\n  (dateFinal - dateInitial) / (1000 * 3600 * 24);\n\n// 예시\ngetDaysDiffBetweenDates(new Date('2017-12-13'), new Date('2017-12-22')); // 9","// maxBy\n// 제공된 함수를 사용하여 각 요소를 값에 매핑 한 후 배열의 최대 값을 반환합니다.\n// \n// Array.map()을 사용하여 각 요소를 fn, Math.max()에서 반환 한 값에 매핑하여 최대 값을 가져옵니다.\n\nconst maxBy = (arr, fn) => Math.max(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));\n\n// 예시\nmaxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 8\nmaxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 8","// isNil\n// 지정된 값이 null 또는 미정 도리의 경우는 true를, 그렇지 않은 경우는 false를 리턴합니다.\n// \n// 완전 항등 연산자를 사용하여 값과 val이 null 또는 undefined인지 확인하십시오.\n\nconst isNil = val => val === undefined || val === null;\n\n// 예시\nisNil(null); // true\nisNil(undefined); // true","// toHash\n// 주어진 Array-like를 값 해시 (키 저장 데이터 스토어)로 축소합니다.\n// \n// Iterable 또는 Array와 유사한 구조가 있으면 제공된 객체에서 Array.prototype.reduce.call()을 호출하여 단계를 건너 뛰고 참조 값에 의해 키가있는 객체를 반환합니다.\n\nconst toHash = (object, key) =>\n  Array.prototype.reduce.call(\n    object,\n    (acc, data, index) => ((acc[!key ? index : data[key]] = data), acc),\n    {}\n  );\n\n// 예시\ntoHash([4, 3, 2, 1]); // { 0: 4, 1: 3, 2: 2, 1: 1 }\ntoHash([{ a: 'label' }], 'a'); // { label: { a: 'label' } }\n// A more in depth example:\nlet users = [{ id: 1, first: 'Jon' }, { id: 2, first: 'Joe' }, { id: 3, first: 'Moe' }];\nlet managers = [{ manager: 1, employees: [2, 3] }];\n// We use function here because we want a bindable reference, but a closure referencing the hash would work, too.\nmanagers.forEach(\n  manager =>\n    (manager.employees = manager.employees.map(function(id) {\n      return this[id];\n    }, toHash(users, 'id')))\n);\nmanagers; // [ { manager:1, employees: [ { id: 2, first: \"Joe\" }, { id: 3, first: \"Moe\" } ] } ]","// scrollToTop\n// 부드럽게 - 페이지 상단으로 스크롤합니다.\n// \n// document.documentElement.scrollTop 또는 document.body.scrollTop을 사용하여 위에서 거리를 가져옵니다.\n// 상단에서 거리의 일부분만큼 스크롤하십시오. 스크롤을 움직이게하려면 window.requestAnimationFrame()을 사용하십시오.\n\nconst scrollToTop = () => {\n  const c = document.documentElement.scrollTop || document.body.scrollTop;\n  if (c > 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, c - c / 8);\n  }\n};\n\n// 예시\nscrollToTop();","// isFunction\n// 지정된 인수가 함수인지 확인합니다.\n// \n// typeof를 사용하여 값이 함수 프리미티브로 분류되는지 확인합니다.\n\nconst isFunction = val => typeof val === 'function';\n\n// 예시\nisFunction('x'); // false\nisFunction(x => x); // true","// recordAnimationFrames\n// 각 애니메이션 프레임에서 제공된 콜백을 호출합니다.\n// \n// 재귀를 사용하십시오.\n// 실행이 사실이라면 제공된 콜백을 호출하는 window.requestAnimationFrame()을 계속 호출하십시오.\n// 기록을 수동으로 제어 할 수 있도록 시작 및 중지의 두 가지 방법으로 객체를 반환합니다.\n// 함수가 호출 될 때 암시 적으로 start를 호출하려면 두 번째 인수 인 autoStart를 생략하십시오.\n\nconst recordAnimationFrames = (callback, autoStart = true) => {\n  let running = true,\n    raf;\n  const stop = () => {\n    running = false;\n    cancelAnimationFrame(raf);\n  };\n  const start = () => {\n    running = true;\n    run();\n  };\n  const run = () => {\n    raf = requestAnimationFrame(() => {\n      callback();\n      if (running) run();\n    });\n  };\n  if (autoStart) start();\n  return { start, stop };\n};\n\n// 예시\nconst cb = () => console.log('Animation frame fired');\nconst recorder = recordAnimationFrames(cb); // logs 'Animation frame fired' on each animation frame\nrecorder.stop(); // stops logging\nrecorder.start(); // starts again\nconst recorder2 = recordAnimationFrames(cb, false); // `start` needs to be explicitly called to begin recording frames","// pick\n// 지정된 키에 해당하는 키 - 값 쌍을 객체에서 선택합니다.\n// \n// Array.reduce()를 사용하여 필터링 된 / 선택된 키를 객체에 키가 있으면 해당 키 - 값 쌍을 가진 객체로 다시 변환합니다.\n\nconst pick = (obj, arr) =>\n  arr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});\n\n// 예시\npick({ a: 1, b: '2', c: 3 }, ['a', 'c']); // { 'a': 1, 'c': 3 }","// observeMutations ![advanced](/advanced.svg)\n// 새 MutationObserver를 반환하고 지정된 요소의 각 변형에 대해 제공된 콜백을 실행합니다.\n// \n// 주어진 요소의 돌연변이를 관찰하려면 [MutationObserver] (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)를 사용하십시오.\n// Array.forEach()를 사용하여 관찰 된 각 변이에 대한 콜백을 실행합니다.\n// 기본 [옵션] (https://developer.mozilla.org/en/US/docs/Web/API/MutationObserver#MutationObserverInit) (모두 true)을 사용하려면 세 번째 인수 인 options을 생략하십시오.\n\nconst observeMutations = (element, callback, options) => {\n  const observer = new MutationObserver(mutations => mutations.forEach(m => callback(m)));\n  observer.observe(\n    element,\n    Object.assign(\n      {\n        childList: true,\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        subtree: true\n      },\n      options\n    )\n  );\n  return observer;\n};\n\n// 예시\nconst obs = observeMutations(document, console.log); // Logs all mutations that happen on the page\nobs.disconnect(); // Disconnects the observer and stops logging mutations on the page","// hashBrowser ![advanced](/advanced.svg)\n// [SHA-256] (https://en.wikipedia.org/wiki/SHA-2) 알고리즘을 사용하여 값에 대한 해시를 만듭니다. 약속을 반환합니다.\n// \n// [SubtleCrypto] (https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) API를 사용하여 주어진 값에 대한 해시를 생성하십시오.\n\nconst hashBrowser = val =>\n  crypto.subtle.digest('SHA-256', new TextEncoder('utf-8').encode(val)).then(h => {\n    let hexes = [],\n      view = new DataView(h);\n    for (let i = 0; i < view.byteLength; i += 4)\n      hexes.push(('00000000' + view.getUint32(i).toString(16)).slice(-8));\n    return hexes.join('');\n  });\n\n// 예시\nhashBrowser(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'","// bindKey\n// 선택적으로 객체의 지정된 키에서 메소드를 호출하는 함수를 작성합니다. 선택적으로 인수의 시작 부분에 추가 매개 변수를 추가합니다.\n// \n// Function.apply()를 사용하여 컨텍스트 [fn]에 컨텍스트를 바인딩하는 함수를 반환하십시오.\n// 스프레드 연산자 (...)를 사용하여 제공된 매개 변수를 인수 앞에 추가하십시오.\n\nconst bindKey = (context, fn, ...boundArgs) => (...args) =>\n  context[fn].apply(context, [...boundArgs, ...args]);\n\n// 예시\nconst freddy = {\n  user: 'fred',\n  greet: function(greeting, punctuation) {\n    return greeting + ' ' + this.user + punctuation;\n  }\n};\nconst freddyBound = bindKey(freddy, 'greet');\nconsole.log(freddyBound('hi', '!')); // 'hi fred!'","// average\n// 두 개 이상의 숫자의 평균을 구합니다.\n// \n// Array.reduce()를 사용하여 값을 0으로 초기화 한 누적기에 각 값을 더하고 배열의 길이로 나눕니다.\n\nconst average = (...nums) => nums.reduce((acc, val) => acc + val, 0) / nums.length;\n\n// 예시\naverage(...[1, 2, 3]); // 2\naverage(1, 2, 3); // 2","// on\n// 이벤트 위임을 사용할 수있는 기능을 가진 요소에 이벤트 수신기를 추가합니다.\n// \n// EventTarget.addEventListener()를 사용하여 요소에 이벤트 리스너를 추가합니다. 옵션 객체에 제공된 대상 속성이있는 경우 이벤트 대상이 지정된 대상과 일치하는지 확인한 다음 올바른이 컨텍스트를 제공하여 콜백을 호출합니다.\n// [off] (# off)와 함께 사용할 수 있도록 사용자 정의 위임자 함수에 대한 참조를 반환합니다.\n// 비 위임 동작 및 이벤트 버블 링을 기본값으로 사용하지 않습니다.\n\nconst on = (el, evt, fn, opts = {}) => {\n  const delegatorFn = e => e.target.matches(opts.target) && fn.call(e.target, e);\n  el.addEventListener(evt, opts.target ? delegatorFn : fn, opts.options || false);\n  if (opts.target) return delegatorFn;\n};\n\n// 예시\nconst fn = () => console.log('!');\non(document.body, 'click', fn); // logs '!' upon clicking the body\non(document.body, 'click', fn, { target: 'p' }); // logs '!' upon clicking a `p` element child of the body\non(document.body, 'click', fn, { options: true }); // use capturing instead of bubbling","// drop\n// 왼쪽에서 n 개 요소가 제거 된 새 배열을 반환합니다.\n// \n// Array.slice()를 사용하여 왼쪽에서 지정된 수의 요소를 제거합니다.\n\nconst drop = (arr, n = 1) => arr.slice(n);\n\n// 예시\ndrop([1, 2, 3]); // [2,3]\ndrop([1, 2, 3], 2); // [3]\ndrop([1, 2, 3], 42); // []","// initializeArrayWithRangeRight\n// 시작과 끝이 공통 차이 단계와 함께 포함되는 지정된 범위의 숫자가 들어있는 배열을 역순으로 초기화합니다.\n// \n// Array.from (Math.ceil ((end + 1-start) / step))을 사용하여 원하는 길이의 배열을 만듭니다 (요소의 양은 (end-start) / step 또는 (end + 1-start ) / end), Array.map()은 범위에서 원하는 값으로 채 웁니다.\n// start를 생략하면 기본값 0을 사용할 수 있습니다.\n// step을 생략하면 기본값 1을 사용할 수 있습니다.\n\nconst initializeArrayWithRangeRight = (end, start = 0, step = 1) =>\n  Array.from({ length: Math.ceil((end + 1 - start) / step) }).map(\n    (v, i, arr) => (arr.length - i - 1) * step + start\n  );\n\n// 예시\ninitializeArrayWithRangeRight(5); // [5,4,3,2,1,0]\ninitializeArrayWithRangeRight(7, 3); // [7,6,5,4,3]\ninitializeArrayWithRangeRight(9, 0, 2); // [8,6,4,2,0]","// hexToRGB ![advanced](/advanced.svg)\n// 알파 값이 제공되면 색상 코드를 rgb () 또는 rgba () 문자열로 변환합니다.\n// \n// & (and) 연산자와 함께 비트 오른쪽 시프트 연산자와 마스크 비트를 사용하여 16 진수 색상 코드 (#가 붙거나 붙지 않음)를 RGB 값이있는 문자열로 변환합니다. 3 자리 컬러 코드 인 경우 먼저 6 자리 버전으로 변환하십시오. 알파 값이 6 자리 16 진수와 함께 제공되면 rgba () 문자열을 반환합니다.\n\nconst hexToRGB = hex => {\n  let alpha = false,\n    h = hex.slice(hex.startsWith('#') ? 1 : 0);\n  if (h.length === 3) h = [...h].map(x => x + x).join('');\n  else if (h.length === 8) alpha = true;\n  h = parseInt(h, 16);\n  return (\n    'rgb' +\n    (alpha ? 'a' : '') +\n    '(' +\n    (h >>> (alpha ? 24 : 16)) +\n    ', ' +\n    ((h & (alpha ? 0x00ff0000 : 0x00ff00)) >>> (alpha ? 16 : 8)) +\n    ', ' +\n    ((h & (alpha ? 0x0000ff00 : 0x0000ff)) >>> (alpha ? 8 : 0)) +\n    (alpha ? `, ${h & 0x000000ff}` : '') +\n    ')'\n  );\n};\n\n// 예시\nhexToRGB('#27ae60ff'); // 'rgba(39, 174, 96, 255)'\nhexToRGB('27ae60'); // 'rgb(39, 174, 96)'\nhexToRGB('#fff'); // 'rgb(255, 255, 255)'","// isAbsoluteURL\n// 지정된 캐릭터 라인이 절대 URL의 경우는 true를 돌려 주어, 그렇지 않은 경우는 false를 돌려줍니다.\n// \n// 문자열이 절대 URL인지 테스트하려면 정규식을 사용하십시오.\n\nconst isAbsoluteURL = str => /^[a-z][a-z0-9+.-]*:/.test(str);\n\n// 예시\nisAbsoluteURL('https://google.com'); // true\nisAbsoluteURL('ftp://www.myserver.net'); // true\nisAbsoluteURL('/foo/bar'); // false","// isBrowserTabFocused\n// 페이지의 브라우저 탭에 포커스가 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// 페이지 가시성 API에서 도입 된 Document.hidden 속성을 사용하여 페이지의 브라우저 탭이 표시되는지 또는 숨겨 지는지 확인합니다.\n\nconst isBrowserTabFocused = () => !document.hidden;\n\n// 예시\nisBrowserTabFocused(); // true","// digitize\n// 숫자를 숫자 배열로 변환합니다.\n// \n// 스프레드 연산자 (...)를 사용하여 숫자를 문자열로 변환하여 배열을 만듭니다.\n// Array.map() 및 parseInt()를 사용하여 각 값을 정수로 변환하십시오.\n\nconst digitize = n => [...`${n}`].map(i => parseInt(i));\n\n// 예시\ndigitize(123); // [1, 2, 3]","// truthCheckCollection\n// 술어 (두 번째 인수)가 콜렉션의 모든 요소 (첫 번째 인수)에서 사실인지 여부를 확인합니다.\n// \n// Array.every()를 사용하여 전달 된 각 객체가 지정된 속성을 갖고 있는지와 진실 값을 반환하는지 확인합니다.\n\nconst truthCheckCollection = (collection, pre) => collection.every(obj => obj[pre]);\n\n// 예시\ntruthCheckCollection([{ user: 'Tinky-Winky', sex: 'male' }, { user: 'Dipsy', sex: 'male' }], 'sex'); // true","// forOwn\n// 객체의 모든 속성을 반복하고 각 객체의 콜백을 실행합니다.\n// \n// Object.keys (obj)를 사용하여 객체의 모든 속성을 가져오고 Array.forEach()는 각 키 - 값 쌍에 대해 제공된 함수를 실행합니다. 콜백은 값, 키 및 객체의 세 가지 인수를받습니다.\n\nconst forOwn = (obj, fn) => Object.keys(obj).forEach(key => fn(obj[key], key, obj));\n\n// 예시\nforOwn({ foo: 'bar', a: 1 }, v => console.log(v)); // 'bar', 1","// objectFromPairs\n// 지정된 키 - 값 쌍에서 객체를 만듭니다.\n// \n// Array.reduce()를 사용하여 키 - 값 쌍을 만들고 결합하십시오.\n\nconst objectFromPairs = arr => arr.reduce((a, v) => ((a[v[0]] = v[1]), a), {});\n\n// 예시\nobjectFromPairs([['a', 1], ['b', 2]]); // {a: 1, b: 2}","// pullAtIndex\n// 원래의 배열을 변경하여 지정된 인덱스의 값을 필터링합니다.\n// \n// Array.filter() 및 Array.includes()를 사용하여 필요하지 않은 값을 추출합니다.\n// Array.length = 0을 사용하면 길이를 0으로 재설정하고 Array.push()를 사용하여 전달 된 값을 변경하여 끌어온 값만 다시 채 웁니다.\n// pull 된 값을 추적하려면 Array.push()를 사용하십시오.\n\nconst pullAtIndex = (arr, pullArr) => {\n  let removed = [];\n  let pulled = arr\n    .map((v, i) => (pullArr.includes(i) ? removed.push(v) : v))\n    .filter((v, i) => !pullArr.includes(i));\n  arr.length = 0;\n  pulled.forEach(v => arr.push(v));\n  return removed;\n};\n\n// 예시\nlet myArray = ['a', 'b', 'c', 'd'];\nlet pulled = pullAtIndex(myArray, [1, 3]); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]","// isNull\n// 지정된 값이 null의 경우는 true를, 그렇지 않은 경우는 false를 리턴합니다.\n// \n// 완전 항등 연산자를 사용하여 값과 val이 null인지 확인하십시오.\n\nconst isNull = val => val === null;\n\n// 예시\nisNull(null); // true","// JSONToFile\n// JSON 객체를 파일에 씁니다.\n// \n// .json 파일에 json 객체를 작성하려면 fs.writeFile(), 템플릿 리터럴 및 JSON.stringify()를 사용하십시오.\n\nconst fs = require('fs');\nconst JSONToFile = (obj, filename) =>\n  fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2));\n\n// 예시\nJSONToFile({ test: 'is passed' }, 'testJsonFile'); // writes the object to 'testJsonFile.json'","// differenceWith\n// comparator 함수가 반환하지 않는 배열의 모든 값을 필터링합니다.\n// \n// Array.filter() 및 Array.findIndex()를 사용하여 적절한 값을 찾습니다.\n\nconst differenceWith = (arr, val, comp) => arr.filter(a => val.findIndex(b => comp(a, b)) === -1);\n\n// 예시\ndifferenceWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2]","// reduceSuccessive\n// 누적 기 및 배열의 각 요소에 대해 왼쪽에서 오른쪽으로 함수를 적용하여 연속적으로 감소 된 값의 배열을 반환합니다.\n// \n// 주어진 함수에 Array.reduce()를 사용하여 각각의 새로운 결과를 저장합니다.\n\nconst reduceSuccessive = (arr, fn, acc) =>\n  arr.reduce((res, val, i, arr) => (res.push(fn(res.slice(-1)[0], val, i, arr)), res), [acc]);\n\n// 예시\nreduceSuccessive([1, 2, 3, 4, 5, 6], (acc, val) => acc + val, 0); // [0, 1, 3, 6, 10, 15, 21]","// sortCharactersInString\n// 알파벳순으로 문자열의 문자를 정렬합니다.\n// \n// str에서 문자를 정렬하려면 spread 연산자 (...), Array.sort() 및 String.localeCompare()를 사용하고 String.join ( '')을 사용하여 재결합합니다.\n\nconst sortCharactersInString = str => [...str].sort((a, b) => a.localeCompare(b)).join('');\n\n// 예시\nsortCharactersInString('cabbage'); // 'aabbceg'","// getStyle\n// 지정된 요소에 대한 CSS 규칙 값을 반환합니다.\n// \n// Window.getComputedStyle()을 사용하여 지정된 요소에 대한 CSS 규칙 값을 가져옵니다.\n\nconst getStyle = (el, ruleName) => getComputedStyle(el)[ruleName];\n\n// 예시\ngetStyle(document.querySelector('p'), 'font-size'); // '16px'","// pullBy ![advanced](/advanced.svg)\n// 지정된 반복자 함수를 기반으로 지정된 값을 필터링하기 위해 원래 배열을 변경합니다.\n// \n// 함수에 제공된 마지막 인수가 있는지 확인하십시오.\n// Array.map()을 사용하여 반복자 함수 fn을 모든 배열 요소에 적용합니다.\n// Array.filter() 및 Array.includes()를 사용하여 필요하지 않은 값을 추출합니다.\n// Array.length = 0을 사용하면 길이를 0으로 재설정하고 Array.push()를 사용하여 전달 된 값을 변경하여 끌어온 값만 다시 채 웁니다.\n\nconst pullBy = (arr, ...args) => {\n  const length = args.length;\n  let fn = length > 1 ? args[length - 1] : undefined;\n  fn = typeof fn == 'function' ? (args.pop(), fn) : undefined;\n  let argState = (Array.isArray(args[0]) ? args[0] : args).map(val => fn(val));\n  let pulled = arr.filter((v, i) => !argState.includes(fn(v)));\n  arr.length = 0;\n  pulled.forEach(v => arr.push(v));\n};\n\n// 예시\nvar myArray = [{ x: 1 }, { x: 2 }, { x: 3 }, { x: 1 }];\npullBy(myArray, [{ x: 1 }, { x: 3 }], o => o.x); // myArray = [{ x: 2 }]","// dropWhile\n// 전달 된 함수가 true를 반환 할 때까지 배열의 요소를 제거합니다. 배열의 나머지 요소를 반환합니다.\n// \n// Array.slice()를 사용하여 배열의 루프를 반복하여 함수의 반환 값이 true가 될 때까지 배열의 첫 번째 요소를 삭제합니다.\n// 나머지 요소를 반환합니다.\n\nconst dropWhile = (arr, func) => {\n  while (arr.length > 0 && !func(arr[0])) arr = arr.slice(1);\n  return arr;\n};\n\n// 예시\ndropWhile([1, 2, 3, 4], n => n >= 3); // [3,4]","// none\n// 제공된 조건부 함수가 컬렉션의 모든 요소에 대해 false를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// Array.some()을 사용하여 콜렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다.\n// 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오.\n\nconst none = (arr, fn = Boolean) => !arr.some(fn);\n\n// 예시\nnone([0, 1, 3, 0], x => x == 2); // true\nnone([0, 0, 0]); // true","// elo ![advanced](/advanced.svg)\n// [Elo rating system] (https://en.wikipedia.org/wiki/Elo_rating_system)을 사용하여 두 명 이상의 상대방 사이의 새 등급을 계산합니다. 그것은 배열을 취한다.\n// 사전 평가 등급을 포함하는 배열을 반환합니다.\n// 배열은 최우수 수행자에서 최악의 수행자 (승자 -> 패자)로 정렬해야합니다.\n// \n// 지수 ** 연산자 및 수학 연산자를 사용하여 예상 점수 (승리 확률)를 계산하십시오.\n// 각 상대의 새로운 등급을 계산하십시오.\n// 각 순열을 사용하여 각 플레이어의 포스트 Elo 등급을 쌍으로 계산하여 등급을 반복합니다.\n// 기본 k 인자 인 32를 사용하려면 두 번째 인수를 생략하십시오.\n\nconst elo = ([...ratings], kFactor = 32, selfRating) => {\n  const [a, b] = ratings;\n  const expectedScore = (self, opponent) => 1 / (1 + 10 ** ((opponent - self) / 400));\n  const newRating = (rating, i) =>\n    (selfRating || rating) + kFactor * (i - expectedScore(i ? a : b, i ? b : a));\n  if (ratings.length === 2) {\n    return [newRating(a, 1), newRating(b, 0)];\n  }\n  for (let i = 0, len = ratings.length; i < len; i++) {\n    let j = i;\n    while (j < len - 1) {\n      j++;\n      [ratings[i], ratings[j]] = elo([ratings[i], ratings[j]], kFactor);\n    }\n  }\n  return ratings;\n};\n\n// 예시\n// Standard 1v1s\nelo([1200, 1200]); // [1216, 1184]\nelo([1200, 1200], 64); // [1232, 1168]\n// 4 player FFA, all same rank\nelo([1200, 1200, 1200, 1200]).map(Math.round); // [1246, 1215, 1185, 1154]\n/*\nFor teams, each rating can adjusted based on own team's average rating vs.\naverage rating of opposing team, with the score being added to their\nown individual rating by supplying it as the third argument.\n*/","// createEventHub ![advanced](/advanced.svg)\n// emit, on 및 off 메서드가있는 pub / sub ([publish-subscribe] (https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)) 이벤트 허브를 만듭니다.\n// \n// Object.create (null)를 사용하면 Object.prototype에서 속성을 상속하지 않는 빈 허브 객체를 만들 수 있습니다.\n// emit의 경우 이벤트 인수를 기반으로 핸들러 배열을 분석 한 다음 데이터를 인수로 전달하여 Array.forEach()로 각 핸들러를 실행합니다.\n// on의 경우 이벤트가 존재하지 않으면 이벤트의 배열을 만든 다음 Array.push()를 사용하여 핸들러를 추가합니다.\n// 배열에.\n// off의 경우 Array.findIndex()를 사용하여 이벤트 배열에서 핸들러의 인덱스를 찾고 Array.splice()를 사용하여 제거합니다.\n\nconst createEventHub = () => ({\n  hub: Object.create(null),\n  emit(event, data) {\n    (this.hub[event] || []).forEach(handler => handler(data));\n  },\n  on(event, handler) {\n    if (!this.hub[event]) this.hub[event] = [];\n    this.hub[event].push(handler);\n  },\n  off(event, handler) {\n    const i = (this.hub[event] || []).findIndex(h => h === handler);\n    if (i > -1) this.hub[event].splice(i, 1);\n  }\n});\n\n// 예시\nconst handler = data => console.log(data);\nconst hub = createEventHub();\nlet increment = 0;\n\n// Subscribe: listen for different types of events\nhub.on('message', handler);\nhub.on('message', () => console.log('Message event fired'));\nhub.on('increment', () => increment++);\n\n// Publish: emit events to invoke all handlers subscribed to them, passing the data to them as an argument\nhub.emit('message', 'hello world'); // logs 'hello world' and 'Message event fired'\nhub.emit('message', { hello: 'world' }); // logs the object and 'Message event fired'\nhub.emit('increment'); // `increment` variable is now 1\n\n// Unsubscribe: stop a specific handler from listening to the 'message' event\nhub.off('message', handler);","// getScrollPosition\n// 현재 페이지의 스크롤 위치를 반환합니다.\n// \n// 정의 된 경우 pageXOffset 및 pageYOffset을 사용하고, 그렇지 않으면 scrollLeft 및 scrollTop을 사용하십시오.\n// el을 생략하면 window의 기본값을 사용할 수 있습니다.\n\nconst getScrollPosition = (el = window) => ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop\n});\n\n// 예시\ngetScrollPosition(); // {x: 0, y: 200}","// omit\n// 지정된 키에 해당하는 키 - 값 쌍을 객체에서 생략합니다.\n// \n// Object.keys (obj), Array.filter() 및 Array.includes()를 사용하여 제공된 키를 제거하십시오.\n// Array.reduce()를 사용하여 필터링 된 키를 해당 키 - 값 쌍을 가진 객체로 다시 변환합니다.\n\nconst omit = (obj, arr) =>\n  Object.keys(obj)\n    .filter(k => !arr.includes(k))\n    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});\n\n// 예시\nomit({ a: 1, b: '2', c: 3 }, ['b']); // { 'a': 1, 'c': 3 }","// overArgs\n// 인수가 변환 된 제공된 함수를 호출하는 함수를 만듭니다.\n// \n// Array.map()을 사용하여 변환 연산자 (...)와 조합하여 args에 변환을 적용하여 변환 된 인수를 fn에 전달합니다.\n\nconst overArgs = (fn, transforms) => (...args) => fn(...args.map((val, i) => transforms[i](val)));\n\n// 예시\nconst square = n => n * n;\nconst double = n => n * 2;\nconst fn = overArgs((x, y) => [x, y], [square, double]);\nfn(9, 3); // [81, 6]","// currentURL\n// 현재의 URL를 돌려줍니다.\n// \n// window.location.href를 사용하여 현재 URL을 가져옵니다.\n\nconst currentURL = () => window.location.href;\n\n// 예시\ncurrentURL(); // 'https://google.com'","// initial\n// 마지막 배열을 제외한 배열의 모든 원소를 반환합니다.\n// \n// arr.slice (0, -1)를 사용하여 배열의 마지막 요소를 제외한 모든 요소를 반환합니다.\n\nconst initial = arr => arr.slice(0, -1);\n\n// 예시\ninitial([1, 2, 3]); // [1,2]","// getMeridiemSuffixOfInteger\n// 정수를 접미사 문자열로 변환하고 해당 값을 기준으로 am 또는 pm을 추가합니다.\n// \n// 모듈러스 연산자 (%)와 조건부 검사를 사용하여 정수를 meridiem 접미사가있는 문자열 형식의 12 시간 형식으로 변환합니다.\n\nconst getMeridiemSuffixOfInteger = num =>\n  num === 0 || num === 24\n    ? 12 + 'am'\n    : num === 12\n      ? 12 + 'pm'\n      : num < 12\n        ? (num % 12) + 'am'\n        : (num % 12) + 'pm';\n\n// 예시\ngetMeridiemSuffixOfInteger(0); // \"12am\"\ngetMeridiemSuffixOfInteger(11); // \"11am\"\ngetMeridiemSuffixOfInteger(13); // \"1pm\"\ngetMeridiemSuffixOfInteger(25); // \"1pm\"","// removeNonASCII\n// 인쇄 할 수없는 ASCII 문자를 제거합니다.\n// \n// 일반 표현식을 사용하여 인쇄 할 수없는 ASCII 문자를 제거하십시오.\n\nconst removeNonASCII = str => str.replace(/[^\\x20-\\x7E]/g, '');\n\n// 예시\nremoveNonASCII('äÄçÇéÉêlorem-ipsumöÖÐþúÚ'); // 'lorem-ipsum'","// UUIDGeneratorNode\n// Node.JS에 UUID를 생성합니다.\n// \n// crypto API를 사용하여 [RFC4122] (https://www.ietf.org/rfc/rfc4122.txt) 버전 4와 호환되는 UUID를 생성하십시오.\n\nconst crypto = require('crypto');\nconst UUIDGeneratorNode = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (c ^ (crypto.randomBytes(1)[0] & (15 >> (c / 4)))).toString(16)\n  );\n\n// 예시\nUUIDGeneratorNode(); // '79c7c136-60ee-40a2-beb2-856f1feabefc'","// isSymbol\n// 지정된 인수가 심볼인가 어떤지를 판정합니다.\n// \n// typeof를 사용하여 값이 기호 프리미티브로 분류되는지 확인하십시오.\n\nconst isSymbol = val => typeof val === 'symbol';\n\n// 예시\nisSymbol(Symbol('x')); // true","// intersectionWith\n// 제공된 비교 함수를 사용하여 두 배열에있는 요소의 목록을 반환합니다.\n// \n// 제공된 비교 자와 함께 Array.filter() 및 Array.findIndex()를 사용하여 교차 값을 결정합니다.\n\nconst intersectionWith = (a, b, comp) => a.filter(x => b.findIndex(y => comp(x, y)) !== -1);\n\n// 예시\nintersectionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1.5, 3, 0]","// converge\n// 수렴 함수와 분기 함수 목록을 받아들이고 각 분기 함수를 인수에 적용하는 함수를 반환하며 분기 함수의 결과는 인수로 수렴 함수에 전달됩니다.\n// \n// Array.map() 및 Function.apply()를 사용하여 각 함수를 주어진 인수에 적용합니다.\n// 스프레드 연산자 (...)를 사용하여 다른 모든 기능의 결과와 함께 표지 작성자를 호출하십시오.\n\nconst converge = (converger, fns) => (...args) => converger(...fns.map(fn => fn.apply(null, args)));\n\n// 예시\nconst average = converge((a, b) => a / b, [\n  arr => arr.reduce((a, v) => a + v, 0),\n  arr => arr.length\n]);\naverage([1, 2, 3, 4, 5, 6, 7]); // 4","// getType\n// 값의 네이티브 형을 돌려줍니다.\n// \n// 값이 정의되지 않았거나 null 인 경우 값의 소문자로 표시된 생성자 이름, \"undefined\"또는 \"null\"을 반환합니다.\n\nconst getType = v =>\n  v === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();\n\n// 예시\ngetType(new Set([1, 2, 3])); // 'set'","// prettyBytes\n// 숫자를 바이트로 사람이 읽을 수있는 문자열로 변환합니다.\n// \n// 지수를 기반으로 액세스 할 유닛 배열 사전을 사용하십시오.\n// 숫자를 특정 자릿수로 자르려면 Number.toPrecision()을 사용하십시오.\n// 미리 지정된 문자열을 제공된 옵션과 음수인지 여부를 고려하여 구성하여 반환하십시오.\n// 두 번째 인수 인 precision을 생략하고 기본 정밀도 3 자리를 사용합니다.\n// addSpace라는 세 번째 인수를 생략하여 기본적으로 숫자와 단위 사이에 공백을 추가하십시오.\n\nconst prettyBytes = (num, precision = 3, addSpace = true) => {\n  const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0];\n  const exponent = Math.min(Math.floor(Math.log10(num < 0 ? -num : num) / 3), UNITS.length - 1);\n  const n = Number(((num < 0 ? -num : num) / 1000 ** exponent).toPrecision(precision));\n  return (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent];\n};\n\n// 예시\nprettyBytes(1000); // \"1 KB\"\nprettyBytes(-27145424323.5821, 5); // \"-27.145 GB\"\nprettyBytes(123456789, 3, false); // \"123MB\"","// minBy\n// 제공된 함수를 사용하여 각 요소를 값에 매핑 한 후 배열의 최소값을 반환합니다.\n// \n// Array.map()을 사용하여 각 요소를 fn, Math.min()에서 반환 한 값에 매핑하여 최대 값을 얻습니다.\n\nconst minBy = (arr, fn) => Math.min(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));\n\n// 예시\nminBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 2\nminBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 2","// mapObject ![advanced](/advanced.svg)\n// 함수를 사용하여 배열의 값을 객체에 매핑합니다. 여기서 키 - 값 쌍은 원래 값을 키와 매핑 된 값으로 구성됩니다.\n// \n// 익명 내부 메모리 범위를 사용하여 정의되지 않은 메모리 공간을 선언하고, 클로저를 사용하여 반환 값을 저장합니다. 새 Array를 사용하여 데이터 집합에 함수 맵을 포함하는 배열을 저장하고 쉼표 연산자를 사용하여 한 문맥에서 다른 문으로 이동할 필요없이 두 번째 단계를 반환합니다 (클로저 및 연산 순서로 인해).\n\nconst mapObject = (arr, fn) =>\n  (a => (\n    (a = [arr, arr.map(fn)]), a[0].reduce((acc, val, ind) => ((acc[val] = a[1][ind]), acc), {})\n  ))();\n\n// 예시\nconst squareIt = arr => mapObject(arr, a => a * a);\nsquareIt([1, 2, 3]); // { 1: 1, 2: 4, 3: 9 }","// differenceBy\n// 두 함수의 각 배열 요소에 제공된 함수를 적용한 후 두 배열 간의 차이를 반환합니다.\n// \n// b의 각 요소에 fn을 적용하여 집합을 만든 다음 a에서 fn과 함께 Array.filter()를 사용하여 이전에 만든 집합에 포함되지 않은 값만 유지합니다.\n\nconst differenceBy = (a, b, fn) => {\n  const s = new Set(b.map(v => fn(v)));\n  return a.filter(x => !s.has(fn(x)));\n};\n\n// 예시\ndifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [1.2]\ndifferenceBy([{ x: 2 }, { x: 1 }], [{ x: 1 }], v => v.x); // [ { x: 2 } ]","// flattenObject\n// 키의 패스로 오브젝트를 전개합니다.\n// \n// 재귀를 사용하십시오.\n// Array.reduce()와 결합 된 Object.keys (obj)를 사용하여 모든 리프 노드를 병합 된 경로 노드로 변환합니다.\n// 키의 값이 객체 인 경우이 함수는 적절한 접두어로 자신을 호출하여 Object.assign()을 사용하여 경로를 만듭니다.\n// 그렇지 않으면 적절한 접 두부 키 - 값 쌍을 누적 기 오브젝트에 추가합니다.\n// 모든 키에 접두사가 있어야하는 경우를 제외하고 항상 두 번째 인수 인 prefix를 생략해야합니다.\n\nconst flattenObject = (obj, prefix = '') =>\n  Object.keys(obj).reduce((acc, k) => {\n    const pre = prefix.length ? prefix + '.' : '';\n    if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k));\n    else acc[pre + k] = obj[k];\n    return acc;\n  }, {});\n\n// 예시\nflattenObject({ a: { b: { c: 1 } }, d: 1 }); // { 'a.b.c': 1, d: 1 }","// ---\n// ### arrayToHtmlList\n// \n// 지정된 배열 요소를 <li> 태그로 변환 해, 지정된 id의리스트에 추가합니다.\n// \n// Array.map(), document.querySelector() 및 익명 내부 클로저를 사용하여 html 태그 목록을 만듭니다.\n\nconst arrayToHtmlList = (arr, listID) =>\n  (el => (\n    (el = document.querySelector('#' + listID)),\n    (el.innerHTML += arr.map(item => `<li>${item}</li>`).join(''))\n  ))();\n\n// 예시\narrayToHtmlList(['item 1', 'item 2'], 'myListID');","// toCamelCase\n// 문자열을 camelcase로 변환합니다.\n// \n// 문자열을 단어로 분리하고 각 단어의 첫 문자를 대문자로 합쳐서 정규 표현식을 사용합니다.\n\nconst toCamelCase = str => {\n  let s =\n    str &&\n    str\n      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n      .map(x => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())\n      .join('');\n  return s.slice(0, 1).toLowerCase() + s.slice(1);\n};\n\n// 예시\ntoCamelCase('some_database_field_name'); // 'someDatabaseFieldName'\ntoCamelCase('Some label that needs to be camelized'); // 'someLabelThatNeedsToBeCamelized'\ntoCamelCase('some-javascript-property'); // 'someJavascriptProperty'\ntoCamelCase('some-mixed_string with spaces_underscores-and-hyphens'); // 'someMixedStringWithSpacesUnderscoresAndHyphens'","// findKey\n// 제공된 테스트 함수를 만족하는 첫 번째 키를 반환합니다. 그렇지 않으면 undefined가 리턴됩니다.\n// \n// Object.keys (obj)를 사용하여 객체의 모든 속성 인 Array.find()를 가져와 각 키 - 값 쌍에 대해 제공된 함수를 테스트합니다. 콜백은 값, 키 및 객체의 세 가지 인수를받습니다.\n\nconst findKey = (obj, fn) => Object.keys(obj).find(key => fn(obj[key], key, obj));\n\n// 예시\nfindKey(\n  {\n    barney: { age: 36, active: true },\n    fred: { age: 40, active: false },\n    pebbles: { age: 1, active: true }\n  },\n  o => o['active']\n); // 'barney'","// randomHexColorCode\n// 임의의 16 진수 색상 코드를 생성합니다.\n// \n// Math.random을 사용하여 무작위 24 비트 (6x4bits) 16 진수를 생성하십시오. 비트 시프 팅을 사용하고 toString (16)을 사용하여 16 진수 문자열로 변환하십시오.\n\nconst randomHexColorCode = () => {\n  let n = (Math.random() * 0xfffff * 1000000).toString(16);\n  return '#' + n.slice(0, 6);\n};\n\n// 예시\nrandomHexColorCode(); // \"#e34155\"","// forOwnRight\n// 역순으로 객체의 모든 속성을 반복하고 각 객체에 대한 콜백을 실행합니다.\n// \n// Object.keys (obj)를 사용하여 객체의 모든 속성을 가져오고 Array.reverse ()는 순서를 반대로하고 Array.forEach ()는 각 키 - 값 쌍에 대해 제공된 함수를 실행합니다. 콜백은 값, 키 및 객체의 세 가지 인수를받습니다.\n\nconst forOwnRight = (obj, fn) =>\n  Object.keys(obj)\n    .reverse()\n    .forEach(key => fn(obj[key], key, obj));\n\n// 예시\nforOwnRight({ foo: 'bar', a: 1 }, v => console.log(v)); // 1, 'bar'","// indexOfAll\n// 배열의 val의 모든 인덱스를 반환합니다. val이 발생하지 않으면 []를 반환합니다.\n// \n// Array.reduce()를 사용하여 요소를 반복하고 일치하는 요소의 인덱스를 저장합니다.\n// 인덱스의 배열을 돌려줍니다.\n\nconst indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);\n\n// 예시\nindexOfAll([1, 2, 3, 1, 2, 3], 1); // [0,3]\nindexOfAll([1, 2, 3], 4); // []","// elementContains\n// 부모 요소가 자식 요소를 포함하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// 부모가 자식 요소와 같은 요소가 아닌지 확인하고 parent.contains (child)를 사용하여 부모 요소에 자식 요소가 있는지 확인합니다.\n\nconst elementContains = (parent, child) => parent !== child && parent.contains(child);\n\n// 예시\nelementContains(document.querySelector('head'), document.querySelector('title')); // true\nelementContains(document.querySelector('body'), document.querySelector('body')); // false","// luhnCheck\n// 신용 카드 번호, IMEI 번호, 국가 공급자 식별자 번호 등과 같은 다양한 식별 번호를 확인하는 데 사용되는 [Luhn 알고리즘] (https://en.wikipedia.org/wiki/Luhn_algorithm) 구현\n// \n// parseInt ()와 조합하여 String.split ( ''), Array.reverse () 및 Array.map()을 사용하여 숫자 배열을 가져옵니다.\n// Array.splice (0,1)를 사용하여 마지막 숫자를 가져옵니다.\n// Luhn 알고리즘을 구현하려면 Array.reduce()를 사용하십시오.\n// sum가 10으로 나눌 수있는 경우는 true, 그렇지 않은 경우는 false\n\nconst luhnCheck = num => {\n  let arr = (num + '')\n    .split('')\n    .reverse()\n    .map(x => parseInt(x));\n  let lastDigit = arr.splice(0, 1)[0];\n  let sum = arr.reduce((acc, val, i) => (i % 2 !== 0 ? acc + val : acc + ((val * 2) % 9) || 9), 0);\n  sum += lastDigit;\n  return sum % 10 === 0;\n};\n\n// 예시\nluhnCheck('4485275742308327'); // true\nluhnCheck(6011329933655299); //  false\nluhnCheck(123456789); // false","// remove\n// 지정된 함수가 false를 반환하는 배열에서 요소를 제거합니다.\n// \n// 진리 값을 반환하는 배열 요소를 찾으려면 Array.filter()를 사용하고 Array.splice()를 사용하여 요소를 제거하려면 Array.reduce()를 사용합니다.\n// func은 세 개의 인수 (value, index, array)로 호출됩니다.\n\nconst remove = (arr, func) =>\n  Array.isArray(arr)\n    ? arr.filter(func).reduce((acc, val) => {\n        arr.splice(arr.indexOf(val), 1);\n        return acc.concat(val);\n      }, [])\n    : [];\n\n// 예시\nremove([1, 2, 3, 4], n => n % 2 === 0); // [2, 4]","// uniqueElementsByRight\n// 제공된 비교 함수를 기반으로 배열의 모든 고유 값을 반환합니다.\n// \n// 비교 함수 fn에 따라 각 값의 마지막 고유 발생 만 포함하는 배열에 대해 Array.reduce () 및 Array.some()을 사용합니다.\n// 비교 함수는 두 개의 인수, 즉 비교되는 두 요소의 값을 취합니다.\n\nconst uniqueElementsByRight = (arr, fn) =>\n  arr.reduceRight((acc, v) => {\n    if (!acc.some(x => fn(v, x))) acc.push(v);\n    return acc;\n  }, []);\n\n// 예시\nuniqueElementsByRight(\n  [\n    { id: 0, value: 'a' },\n    { id: 1, value: 'b' },\n    { id: 2, value: 'c' },\n    { id: 1, value: 'd' },\n    { id: 0, value: 'e' }\n  ],\n  (a, b) => a.id == b.id\n); // [ { id: 0, value: 'e' }, { id: 1, value: 'd' }, { id: 2, value: 'c' } ]","// union\n// 두 배열 중 하나에있는 모든 요소를 한 번만 반환합니다.\n// \n// a와 b의 모든 값을 가지는 Set를 생성 해, 배열로 변환합니다.\n\nconst union = (a, b) => Array.from(new Set([...a, ...b]));\n\n// 예시\nunion([1, 2, 3], [4, 3, 2]); // [1,2,3,4]","// insertBefore\n// 지정된 요소의 시작 전에 HTML 문자열을 삽입합니다.\n// \n// htmlString을 파싱하고 el 시작 전에 삽입하려면 'beforebegin'위치와 함께 el.insertAdjacentHTML()을 사용하십시오.\n\nconst insertBefore = (el, htmlString) => el.insertAdjacentHTML('beforebegin', htmlString);\n\n// 예시\ninsertBefore(document.getElementById('myId'), '<p>before</p>'); // <p>before</p> <div id=\"myId\">...</div>","// runPromisesInSeries\n// 일련의 약속을 실행합니다.\n// \n// Array.reduce()를 사용하여 약속 체인을 만듭니다. 여기서 각 약속은 해결 될 때 다음 약속을 반환합니다.\n\nconst runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());\n\n// 예시\nconst delay = d => new Promise(r => setTimeout(r, d));\nrunPromisesInSeries([() => delay(1000), () => delay(2000)]); // Executes each promise sequentially, taking a total of 3 seconds to complete","// objectToPairs\n// 객체에서 키 - 값 쌍 배열의 배열을 만듭니다.\n// \n// Object.keys () 및 Array.map()을 사용하여 객체의 키를 반복하고 키 - 값 쌍이있는 배열을 생성합니다.\n\nconst objectToPairs = obj => Object.keys(obj).map(k => [k, obj[k]]);\n\n// 예시\nobjectToPairs({ a: 1, b: 2 }); // [['a',1],['b',2]]","// btoa\n// 캐릭터 라인의 각 캐릭터가 바이너리 데이터의 1 바이트로서 취급되는 String 오브젝트로부터, base-64로 encode 된 ASCII 캐릭터 라인을 작성합니다.\n// \n// 주어진 문자열에 대한 버퍼를 이진 인코딩으로 만들고 Buffer.toString ( 'base64')을 사용하여 인코딩 된 문자열을 반환합니다.\n\nconst btoa = str => new Buffer(str, 'binary').toString('base64');\n\n// 예시\nbtoa('foobar'); // 'Zm9vYmFy'","// memoize\n// memoized (캐쉬 된) 함수를 돌려줍니다.\n// \n// 새 Map 객체를 인스턴스화하여 빈 캐시를 만듭니다.\n// 먼저 특정 입력 값에 대한 함수 출력이 이미 캐시되어 있는지 확인하거나 그렇지 않은 경우 저장하고 반환합니다. 필요한 경우 memoized 함수가이 컨텍스트를 변경하도록하려면 function 키워드를 사용해야합니다.\n// 이를 반환 된 함수의 속성으로 설정하여 캐시에 대한 액세스를 허용합니다.\n\nconst memoize = fn => {\n  const cache = new Map();\n  const cached = function(val) {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n  cached.cache = cache;\n  return cached;\n};\n\n// 예시\n// See the `anagrams` snippet.\nconst anagramsCached = memoize(anagrams);\nanagramsCached('javascript'); // takes a long time\nanagramsCached('javascript'); // returns virtually instantly since it's now cached\nconsole.log(anagramsCached.cache); // The cached anagrams map","// isArrayLike\n// 제공된 인수가 배열 형 (즉, 반복 가능)인지 확인합니다.\n// \n// 스프레드 연산자 (...)를 사용하여 제공된 인수가 try ... catch 블록 내에서 반복 가능하고 쉼표 연산자 (,)가 적절한 값을 반환하는지 확인하십시오.\n\nconst isArrayLike = val => {\n  try {\n    return [...val], true;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 예시\nisArrayLike(document.querySelectorAll('.className')); // true\nisArrayLike('abc'); // true\nisArrayLike(null); // false","// setStyle\n// 지정된 요소에 대한 CSS 규칙 값을 설정합니다.\n// \n// element.style을 사용하여 지정된 요소의 CSS 규칙 값을 val로 설정합니다.\n\nconst setStyle = (el, ruleName, val) => (el.style[ruleName] = val);\n\n// 예시\nsetStyle(document.querySelector('p'), 'font-size', '20px'); // The first <p> element on the page will have a font-size of 20px","// randomNumberInRange\n// 지정된 범위의 난수를 반환합니다.\n// \n// Math.random()을 사용하여 임의의 값을 생성하고 곱셈을 사용하여 원하는 범위에 매핑합니다.\n\nconst randomNumberInRange = (min, max) => Math.random() * (max - min) + min;\n\n// 예시\nrandomNumberInRange(2, 10); // 6.0211363285087005","// off\n// 요소에서 이벤트 수신기를 제거합니다.\n// \n// 요소에서 이벤트 리스너를 제거하려면 EventTarget.removeEventListener()를 사용하십시오.\n// false를 사용하거나 이벤트 리스너가 추가되었을 때 사용 된 옵션에 따라 지정하도록 네 번째 인수 opts를 생략하십시오.\n\nconst off = (el, evt, fn, opts = false) => el.removeEventListener(evt, fn, opts);\n\n// 예시\nconst fn = () => console.log('!');\ndocument.body.addEventListener('click', fn);\noff(document.body, 'click', fn); // no longer logs '!' upon clicking on the page","// redirect\n// 지정된 URL로 리디렉션합니다.\n// \n// window.location.href 또는 window.location.replace()를 사용하여 url로 리디렉션하십시오.\n// 두 번째 인수를 전달하여 링크 클릭 (true - default) 또는 HTTP 리디렉션 (false)을 시뮬레이트합니다.\n\nconst redirect = (url, asLink = true) =>\n  asLink ? (window.location.href = url) : window.location.replace(url);\n\n// 예시\nredirect('https://google.com');","// isEmpty\n// a 값이 빈 객체, 컬렉션, 맵 또는 세트이고 열거 가능 속성이 없거나 콜렉션으로 간주되지 않는 유형이면 true를 반환합니다.\n// \n// 제공된 값이 널 (NULL)인지 또는 길이가 0인지 점검하십시오.\n\nconst isEmpty = val => val == null || !(Object.keys(val) || val).length;\n\n// 예시\nisEmpty(new Map()); // true\nisEmpty(new Set()); // true\nisEmpty([]); // true\nisEmpty({}); // true\nisEmpty(''); // true\nisEmpty([1, 2]); // false\nisEmpty({ a: 1, b: 2 }); // false\nisEmpty('text'); // false\nisEmpty(123); // true - type is not considered a collection\nisEmpty(true); // true - type is not considered a collection","// takeRightWhile\n// 전달 된 함수가 true를 반환 할 때까지 배열 끝에서 요소를 제거합니다. 삭제 된 요소를 돌려줍니다.\n// \n// 함수에서 반환 된 값이 true가 될 때까지 Array ... key ()에 대해 for ... of 루프를 사용하여 배열을 반복합니다.\n// Array.reverse () 및 Array.slice()를 사용하여 제거 된 요소를 반환합니다.\n\nconst takeRightWhile = (arr, func) => {\n  for (let i of arr.reverse().keys())\n    if (func(arr[i])) return arr.reverse().slice(arr.length - i, arr.length);\n  return arr;\n};\n\n// 예시\ntakeRightWhile([1, 2, 3, 4], n => n < 3); // [3, 4]","// hammingDistance\n// 두 값 사이의 해밍 거리를 계산합니다.\n// \n// XOR 연산자 (^)를 사용하여 두 숫자 사이의 비트 차이를 찾고 toString (2)을 사용하여 이진 문자열로 변환하십시오.\n// match (/ 1 / g)를 사용하여 문자열에서 1의 수를 센다.\n\nconst hammingDistance = (num1, num2) => ((num1 ^ num2).toString(2).match(/1/g) || '').length;\n\n// 예시\nhammingDistance(2, 3); // 1","// sortedLastIndex\n// 정렬 순서를 유지하기 위해 배열에 값을 삽입해야하는 가장 높은 인덱스를 반환합니다.\n// \n// 배열이 내림차순으로 정렬되는지 (느슨하게) 확인하십시오.\n// Array.reverse () 및 Array.findIndex()를 사용하여 요소를 삽입해야하는 적절한 마지막 인덱스를 찾습니다.\n\nconst sortedLastIndex = (arr, n) => {\n  const isDescending = arr[0] > arr[arr.length - 1];\n  const index = arr.reverse().findIndex(el => (isDescending ? n <= el : n >= el));\n  return index === -1 ? 0 : arr.length - index;\n};\n\n// 예시\nsortedLastIndex([10, 20, 30, 30, 40], 30); // 4","// standardDeviation\n// 숫자 배열의 표준 편차를 구합니다.\n// \n// Array.reduce()를 사용하여 평균, 분산 및 값의 분산, 값의 분산의 합계를 계산 한 다음\n// 표준 편차를 결정하십시오.\n// 두 번째 인수를 생략하여 샘플 표준 편차를 얻거나이 값을 true로 설정하여 모집단 표준 편차를 얻을 수 있습니다.\n\nconst standardDeviation = (arr, usePopulation = false) => {\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  return Math.sqrt(\n    arr.reduce((acc, val) => acc.concat((val - mean) ** 2), []).reduce((acc, val) => acc + val, 0) /\n      (arr.length - (usePopulation ? 0 : 1))\n  );\n};\n\n// 예시\nstandardDeviation([10, 2, 38, 23, 38, 23, 21]); // 13.284434142114991 (sample)\nstandardDeviation([10, 2, 38, 23, 38, 23, 21], true); // 12.29899614287479 (population)","// nthArg\n// 인덱스 n에서 인수를 가져 오는 함수를 만듭니다. n가 음수이면 끝에있는 n 번째 인수가 반환됩니다.\n// \n// Array.slice()를 사용하여 인덱스 n에서 원하는 인수를 가져옵니다.\n\nconst nthArg = n => (...args) => args.slice(n)[0];\n\n// 예시\nconst third = nthArg(2);\nthird(1, 2, 3); // 3\nthird(1, 2); // undefined\nconst last = nthArg(-1);\nlast(1, 2, 3, 4, 5); // 5","// serializeCookie\n// 쿠키 이름 - 값 쌍을 Set-Cookie 헤더 문자열로 serialize합니다.\n// \n// 템플릿 리터럴과 encodeURIComponent()를 사용하여 적절한 문자열을 만듭니다.\n\nconst serializeCookie = (name, val) => `${encodeURIComponent(name)}=${encodeURIComponent(val)}`;\n\n// 예시\nserializeCookie('foo', 'bar'); // 'foo=bar'","// sumPower\n// 시작부터 끝까지 (모든 값 포함) 모든 숫자의 거듭 제곱을 반환합니다.\n// \n// Array.fill()을 사용하여 대상 범위 인 Array.map () 및 지수 연산자 (**)에있는 모든 숫자의 배열을 만들어 전원을 높이고 Array.reduce()를 함께 추가합니다.\n// 두 번째 인수 인 power를 생략하고 기본값 인 2를 사용합니다.\n// 기본 시작 값인 1을 사용하려면 세 번째 인수 인 start를 생략하십시오.\n\nconst sumPower = (end, power = 2, start = 1) =>\n  Array(end + 1 - start)\n    .fill(0)\n    .map((x, i) => (i + start) ** power)\n    .reduce((a, b) => a + b, 0);\n\n// 예시\nsumPower(10); // 385\nsumPower(10, 3); //3025\nsumPower(10, 3, 5); //2925","// sum\n// 두 개 이상의 숫자 / 배열의 합을 반환합니다.\n// \n// Array.reduce()를 사용하여 각 값을 누적기에 추가하고 값 0으로 초기화합니다.\n\nconst sum = (...arr) => [...arr].reduce((acc, val) => acc + val, 0);\n\n// 예시\nsum(...[1, 2, 3, 4]); // 10","// initializeArrayWithValues\n// 배열을 초기화하고 지정된 값으로 채 웁니다.\n// \n// Array (n)을 사용하여 원하는 길이의 배열을 만들고 채우기 (v)하여 원하는 값으로 채 웁니다.\n// val을 생략하면 기본값 0을 사용할 수 있습니다.\n\nconst initializeArrayWithValues = (n, val = 0) => Array(n).fill(val);\n\n// 예시\ninitializeArrayWithValues(5, 2); // [2,2,2,2,2]","// tail\n// 첫 번째 요소를 제외한 배열의 모든 요소를 반환합니다.\n// \n// 배열의 길이가 1보다 큰 경우 Array.slice (1)을 반환하고, 그렇지 않으면 전체 배열을 반환합니다.\n\nconst tail = arr => (arr.length > 1 ? arr.slice(1) : arr);\n\n// 예시\ntail([1, 2, 3]); // [2,3]\ntail([1]); // [1]","// isObject\n// 건네받은 값이 객체인가 어떤가를 판정하는 불리언 값을 돌려줍니다.\n// \n// Object 생성자를 사용하여 지정된 값에 대한 객체 래퍼를 만듭니다.\n// 값이 null 또는 미정 도리의 경우, 빈 상태 (empty)의 객체를 작성해 돌려줍니다. Οtherwise, 주어진 값에 해당하는 유형의 객체를 반환합니다.\n\nconst isObject = obj => obj === Object(obj);\n\n// 예시\nisObject([1, 2, 3, 4]); // true\nisObject([]); // true\nisObject(['Hello!']); // true\nisObject({ a: 1 }); // true\nisObject({}); // true\nisObject(true); // false","// symmetricDifferenceBy\n// 두 함수의 각 배열 요소에 제공된 함수를 적용한 후 두 배열 간의 대칭 차이를 반환합니다.\n// \n// 각 배열의 요소에 fn을 적용한 집합을 만든 다음 각 배열의 요소에 Array.filter()를 사용하여 다른 배열에 포함되지 않은 값만 유지합니다.\n\nconst symmetricDifferenceBy = (a, b, fn) => {\n  const sA = new Set(a.map(v => fn(v))),\n    sB = new Set(b.map(v => fn(v)));\n  return [...a.filter(x => !sB.has(fn(x))), ...b.filter(x => !sA.has(fn(x)))];\n};\n\n// 예시\nsymmetricDifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [ 1.2, 3.4 ]","// round\n// 숫자를 지정된 자릿수로 올림합니다.\n// \n// 숫자를 지정된 자릿수로 반올림하려면 Math.round () 및 템플릿 리터럴을 사용하십시오.\n// 두 번째 인수는 생략하고 정수로 반올림합니다.\n\nconst round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);\n\n// 예시\nround(1.005, 2); // 1.01","// all\n// 제공된 조건부 함수가 컬렉션의 모든 요소에 대해 true를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// Array.every()를 사용하여 콜렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다.\n// 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오.\n\nconst all = (arr, fn = Boolean) => arr.every(fn);\n\n// 예시\nall([4, 2, 3], x => x > 1); // true\nall([1, 2, 3]); // true","// counter ![advanced](/advanced.svg)\n// 지정된 범위의 지정된 범위, 단계 및 지속 기간을 사용하여 카운터를 만듭니다.\n// \n// 단계에 적절한 부호가 있는지 확인하고 적절하게 변경하십시오.\n// setInterval()을 Math.abs () 및 Math.floor ()와 함께 사용하여 각각의 새 텍스트 그리기 사이의 시간을 계산합니다.\n// document.querySelector (). innerHTML을 사용하여 선택한 요소의 값을 업데이트합니다.\n// 기본 단계 인 1을 사용하려면 네 번째 매개 변수 인 step을 생략하십시오.\n// 다섯 번째 매개 변수 인 duration을 생략하고 기본 기간 인 2000ms를 사용하십시오.\n\nconst counter = (selector, start, end, step = 1, duration = 2000) => {\n  let current = start,\n    _step = (end - start) * step < 0 ? -step : step,\n    timer = setInterval(() => {\n      current += _step;\n      document.querySelector(selector).innerHTML = current;\n      if (current >= end) document.querySelector(selector).innerHTML = end;\n      if (current >= end) clearInterval(timer);\n    }, Math.abs(Math.floor(duration / (end - start))));\n  return timer;\n};\n\n// 예시\ncounter('#my-id', 1, 1000, 5, 2000); // Creates a 2-second timer for the element with id=\"my-id\"","// mapValues\n// 제공된 객체와 동일한 키를 가진 객체와 각 값에 대해 제공된 함수를 실행하여 생성 된 값을 만듭니다.\n// \n// Object.keys (obj)를 사용하여 객체 키를 반복합니다.\n// Array.reduce()를 사용하여 fn을 사용하여 동일한 키와 매핑 된 값으로 새 객체를 만듭니다.\n\nconst mapValues = (obj, fn) =>\n  Object.keys(obj).reduce((acc, k) => {\n    acc[k] = fn(obj[k], k, obj);\n    return acc;\n  }, {});\n\n// 예시\nconst users = {\n  fred: { user: 'fred', age: 40 },\n  pebbles: { user: 'pebbles', age: 1 }\n};\nmapValues(users, u => u.age); // { fred: 40, pebbles: 1 }","// createElement\n// 문자열에 요소를 추가합니다 (문서에 추가하지 않고).\n// 지정된 캐릭터 라인에 복수의 요소가있는 경우, 최초의 요소 만이 리턴됩니다.\n// \n// document.createElement()를 사용하여 새 요소를 만듭니다.\n// innerHTML을 인수로 제공된 문자열로 설정합니다.\n// ParentNode.firstElementChild를 사용하여 문자열의 요소 버전을 반환합니다.\n\nconst createElement = str => {\n  const el = document.createElement('div');\n  el.innerHTML = str;\n  return el.firstElementChild;\n};\n\n// 예시\nconst el = createElement(\n  `<div class=\"container\">\n    <p>Hello!</p>\n  </div>`\n);\nconsole.log(el.className); // 'container'","// castArray\n// 제공된 값이 배열이 아닌 경우 배열로 캐스팅합니다.\n// \n// Array.isArray()를 사용하여 val이 배열인지 확인한 다음 그대로 반환하거나 배열에 캡슐화합니다.\n\nconst castArray = val => (Array.isArray(val) ? val : [val]);\n\n// 예시\ncastArray('foo'); // ['foo']\ncastArray([1]); // [1]","// validateNumber\n// 지정된 값이 수치의 경우는 true를, 그렇지 않은 경우는 false를 돌려줍니다.\n// \n// ! isNaN()을 parseFloat ()와 함께 사용하여 인수가 숫자인지 확인하십시오.\n// 숫자가 유한한지 확인하려면 isFinite()를 사용하십시오.\n// 강압이 지속되는지 확인하려면 Number()를 사용하십시오.\n\nconst validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;\n\n// 예시\nvalidateNumber('10'); // true","// partition\n// 각 요소에 대해 제공된 함수의 진실성에 따라 요소를 두 개의 배열로 그룹화합니다.\n// \n// Array.reduce()를 사용하여 두 배열의 배열을 만듭니다.\n// Array.push()를 사용하여 fn이 true를 반환하는 요소를 첫 번째 배열에 추가하고 fn이 두 번째 배열에 false를 반환하는 요소를 추가합니다.\n\nconst partition = (arr, fn) =>\n  arr.reduce(\n    (acc, val, i, arr) => {\n      acc[fn(val, i, arr) ? 0 : 1].push(val);\n      return acc;\n    },\n    [[], []]\n  );\n\n// 예시\nconst users = [{ user: 'barney', age: 36, active: false }, { user: 'fred', age: 40, active: true }];\npartition(users, o => o.active); // [[{ 'user': 'fred',    'age': 40, 'active': true }],[{ 'user': 'barney',  'age': 36, 'active': false }]]","// intersectionBy\n// 두 배열의 각 배열 요소에 제공된 함수를 적용한 후 두 배열에있는 요소의 목록을 반환합니다.\n// \n// b의 모든 요소에 fn을 적용한 다음 Set에 Array.filter()를 사용하면 fn이 적용될 때 b에 포함 된 값을 생성하는 요소 만 유지할 수 있습니다.\n\nconst intersectionBy = (a, b, fn) => {\n  const s = new Set(b.map(x => fn(x)));\n  return a.filter(x => s.has(fn(x)));\n};\n\n// 예시\nintersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [2.1]","// initializeNDArray\n// 주어진 값으로 n 차원 배열을 만듭니다.\n// \n// 재귀를 사용하십시오.\n// Array.map()을 사용하여 각 행이 initializeNDArray를 사용하여 초기화 된 새 배열 인 행을 생성하십시오.\n\nconst initializeNDArray = (val, ...args) =>\n  args.length === 0\n    ? val\n    : Array.from({ length: args[0] }).map(() => initializeNDArray(val, ...args.slice(1)));\n\n// 예시\ninitializeNDArray(1, 3); // [1,1,1]\ninitializeNDArray(5, 2, 2, 2); // [[[5,5],[5,5]],[[5,5],[5,5]]]","// fibonacci\n// n 번째 항까지 피보나치 시퀀스를 포함하는 배열을 생성합니다.\n// \n// 최초의 2 개의 값 (0과 1)을 초기화 해, 특정의 길이의 하늘의 배열을 작성합니다.\n// Array.reduce()를 사용하여 처음 두 개를 제외한 마지막 두 값의 합계를 사용하여 배열에 값을 추가합니다.\n\nconst fibonacci = n =>\n  Array.from({ length: n }).reduce(\n    (acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i),\n    []\n  );\n\n// 예시\nfibonacci(6); // [0, 1, 1, 2, 3, 5]","// join\n// 배열의 모든 요소를 문자열에 조인하고이 문자열을 반환합니다. 구분 기호와 끝 구분 기호를 사용합니다.\n// \n// Array.reduce()를 사용하여 요소를 문자열로 결합합니다.\n// 두 번째 인수 인 separator를 생략하고 ','의 기본 구분 기호를 사용하십시오.\n// 세 번째 인수 인 end를 생략하고 기본적으로 구분 기호와 동일한 값을 사용합니다.\n\nconst join = (arr, separator = ',', end = separator) =>\n  arr.reduce(\n    (acc, val, i) =>\n      i === arr.length - 2\n        ? acc + val + end\n        : i === arr.length - 1\n          ? acc + val\n          : acc + val + separator,\n    ''\n  );\n\n// 예시\njoin(['pen', 'pineapple', 'apple', 'pen'], ',', '&'); // \"pen,pineapple,apple&pen\"\njoin(['pen', 'pineapple', 'apple', 'pen'], ','); // \"pen,pineapple,apple,pen\"\njoin(['pen', 'pineapple', 'apple', 'pen']); // \"pen,pineapple,apple,pen\"","// splitLines\n// 여러 줄 문자열을 줄 배열로 나눕니다.\n// \n// 줄 바꿈을 일치시키고 배열을 만들려면 String.split ()과 정규 표현식을 사용하십시오.\n\nconst splitLines = str => str.split(/\\r?\\n/);\n\n// 예시\nsplitLines('This\\nis a\\nmultiline\\nstring.\\n'); // ['This', 'is a', 'multiline', 'string.' , '']","// isValidJSON\n// 제공된 인수가 유효한 JSON인지 확인합니다.\n// \n// 제공된 인수가 유효한 JSON인지 확인하려면 JSON.parse () 및 try ... catch 블록을 사용하십시오.\n\nconst isValidJSON = obj => {\n  try {\n    JSON.parse(obj);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 예시\nisValidJSON('{\"name\":\"Adam\",\"age\":20}'); // true\nisValidJSON('{\"name\":\"Adam\",age:\"20\"}'); // false\nisValidJSON(null); // true","// delay\n// 대기 밀리 세컨드 후에 제공된 함수를 호출합니다.\n// \n// setTimeout()을 사용하여 fn의 실행을 지연하십시오.\n// spread (...) 연산자를 사용하여 함수에 임의의 수의 인수를 제공하십시오.\n\nconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args);\n\n// 예시\ndelay(\n  function(text) {\n    console.log(text);\n  },\n  1000,\n  'later'\n); // Logs 'later' after one second.","// byteSize\n// 캐릭터 라인의 길이를 바이트 단위로 돌려줍니다.\n// \n// 주어진 문자열을 [Blob Object] (https://developer.mozilla.org/en-US/docs/Web/API/Blob)로 변환하고 그 크기를 찾으십시오.\n\nconst byteSize = str => new Blob([str]).size;\n\n// 예시\nbyteSize('😀'); // 4\nbyteSize('Hello World'); // 11","// findLastIndex\n// 제공된 함수가 truey 값을 반환하는 마지막 요소의 인덱스를 반환합니다.\n// \n// Array.map()을 사용하여 각 요소를 색인 및 값이있는 배열에 매핑하십시오.\n// Array.filter()를 사용하여 fn이 false 값을 반환하는 요소를 제거하고 Array.pop()을 사용하여 마지막 값을 가져옵니다.\n\nconst findLastIndex = (arr, fn) =>\n  arr\n    .map((val, i) => [i, val])\n    .filter(([i, val]) => fn(val, i, arr))\n    .pop()[0];\n\n// 예시\nfindLastIndex([1, 2, 3, 4], n => n % 2 === 1); // 2 (index of the value 3)","// dropRight\n// 오른쪽에서 n 개 요소가 제거 된 새 배열을 반환합니다.\n// \n// Array.slice()를 사용하여 오른쪽에서 지정된 수의 요소를 제거합니다.\n\nconst dropRight = (arr, n = 1) => arr.slice(0, -n);\n\n// 예시\ndropRight([1, 2, 3]); // [1,2]\ndropRight([1, 2, 3], 2); // [1]\ndropRight([1, 2, 3], 42); // []","// URLJoin\n// 지정된 모든 URL 세그먼트를 함께 결합한 다음 결과 URL을 정규화합니다.\n// \n// String.join ( '/')을 사용하여 URL 세그먼트를 결합한 다음 다양한 정규 표현식과 함께 일련의 String.replace () 호출을 사용하여 결과 URL을 표준화합니다 (이중 슬래시 제거, 프로토콜에 적절한 슬래시 추가, 매개 변수 앞의 슬래시 제거, 매개 변수 결합 '&'및 첫 번째 매개 변수 구분 기호를 표준화).\n\nconst URLJoin = (...args) =>\n  args\n    .join('/')\n    .replace(/[\\/]+/g, '/')\n    .replace(/^(.+):\\//, '$1://')\n    .replace(/^file:/, 'file:/')\n    .replace(/\\/(\\?|&|#[^!])/g, '$1')\n    .replace(/\\?/g, '&')\n    .replace('&', '?');\n\n// 예시\nURLJoin('http://www.google.com', 'a', '/b/cd', '?foo=123', '?bar=foo'); // 'http://www.google.com/a/b/cd?foo=123&bar=foo'","// filterNonUnique\n// 배열의 고유하지 않은 값을 필터링합니다.\n// \n// 고유 한 값만 포함하는 배열의 경우 Array.filter()를 사용하십시오.\n\nconst filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));\n\n// 예시\nfilterNonUnique([1, 2, 2, 3, 4, 4, 5]); // [1,3,5]","// toDecimalMark\n// toLocaleString()을 사용하여 부동 소수점 산술을 [소수점 이하 자릿수] (https://en.wikipedia.org/wiki/Decimal_mark) 형식으로 변환하십시오. 숫자와 쉼표로 구분 된 문자열을 만듭니다.\n// \n//  js\n// const toDecimalMark = num => num.toLocaleString ( 'en-US');\n// \n// \n// <세부 사항>\n// <summary> 예제 </ summary>\n\n\n\n// 예시\n### toDecimalMark\n\nUse `toLocaleString()` to convert a float-point arithmetic to the [Decimal mark](https://en.wikipedia.org/wiki/Decimal_mark) form. It makes a comma separated string from a number.\n\n ```js\nconst toDecimalMark = num => num.toLocaleString('en-US');\n```\n\n<details>\n<summary>Examples</summary>\n\n```js\ntoDecimalMark(12305030388.9087); // \"12,305,030,388.909\"","// flip\n// Flip은 함수를 인수로 취한 다음 첫 번째 인수를 마지막으로 만듭니다.\n// \n// 가변 인수를받는 클로저를 반환하고 나머지 인수를 적용하기 전에 마지막 인수를 첫 번째 인수로 연결합니다.\n\nconst flip = fn => (first, ...rest) => fn(...rest, first);\n\n// 예시\nlet a = { name: 'John Smith' };\nlet b = {};\nconst mergeFrom = flip(Object.assign);\nlet mergePerson = mergeFrom.bind(null, a);\nmergePerson(b); // == b\nb = {};\nObject.assign(b, a); // == b","// partialRight\n// 수신 한 인수에 부분이 추가 된 fn을 호출하는 함수를 작성합니다.\n// \n// 확산 연산자 (...)를 사용하여 fn의 인수 목록에 부분을 추가하십시오.\n\nconst partialRight = (fn, ...partials) => (...args) => fn(...args, ...partials);\n\n// 예시\nconst greet = (greeting, name) => greeting + ' ' + name + '!';\nconst greetJohn = partialRight(greet, 'John');\ngreetJohn('Hello'); // 'Hello John!'","// nodeListToArray\n// NodeList를 배열로 변환합니다.\n// \n// Array.prototype.slice () 및 Function.prototype.call()을 사용하여 NodeList를 배열로 변환합니다.\n\nconst nodeListToArray = nodeList => Array.prototype.slice.call(nodeList);\n\n// 예시\nnodeListToArray(document.childNodes); // [ <!DOCTYPE html>, html ]","// uniqueElements\n// 배열의 모든 고유 값을 반환합니다.\n// \n// ES6 Set 및 ... rest 연산자를 사용하여 모든 중복 값을 삭제합니다.\n\nconst uniqueElements = arr => [...new Set(arr)];\n\n// 예시\nuniqueElements([1, 2, 2, 3, 4, 4, 5]); // [1,2,3,4,5]","// httpsRedirect\n// 현재 HTTP에있는 경우 페이지를 HTTPS로 리디렉션합니다. 또한, 뒤로 단추를 눌러도 HTTP 페이지로 되돌아갑니다.\n// \n// location.protocol을 사용하여 현재 사용중인 프로토콜을 가져옵니다. HTTPS가 아닌 경우 location.replace()를 사용하여 기존 페이지를 HTTPS 버전의 페이지로 바꿉니다. location.href를 사용하여 전체 주소를 가져 와서 String.split ()으로 분할하고 URL의 프로토콜 부분을 제거하십시오.\n\nconst httpsRedirect = () => {\n  if (location.protocol !== 'https:') location.replace('https://' + location.href.split('//')[1]);\n};\n\n// 예시\nhttpsRedirect(); // If you are on http://mydomain.com, you are redirected to https://mydomain.com","// detectDeviceType\n// 웹 사이트가 모바일 장치 또는 데스크톱 / 랩톱에서 열리고 있음을 감지합니다.\n// \n// 일반 표현식을 사용하여 navigator.userAgent 등록 정보를 테스트하여 장치가 모바일 장치인지 또는 데스크탑 / 랩탑인지 확인하십시오.\n\nconst detectDeviceType = () =>\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n    ? 'Mobile'\n    : 'Desktop';\n\n// 예시\ndetectDeviceType(); // \"Mobile\" or \"Desktop\"","// mask\n// 마지막 문자 수를 제외한 모든 문자를 지정된 마스크 문자로 바꿉니다.\n// \n// String.slice()를 사용하여 마스크해야하는 문자의 부분을 잡고 모든 문자를 마스크 문자로 바꾸려면 Regexp와 함께 String.replace()를 사용하십시오.\n// 마스킹 된 문자를 마스킹되지 않은 문자열의 나머지 부분과 연결하십시오.\n// 두 번째 인수 인 num을 생략하여 기본값 인 4자를 마스크 해제합니다. num이 음수이면 마스크되지 않은 문자가 문자열의 시작 부분에옵니다.\n// 세 번째 인수 인 mask를 생략하여 마스크에 '*'의 기본 문자를 사용하십시오.\n\nconst mask = (cc, num = 4, mask = '*') =>\n  ('' + cc).slice(0, -num).replace(/./g, mask) + ('' + cc).slice(-num);\n\n// 예시\nmask(1234567890); // '******7890'\nmask(1234567890, 3); // '*******890'\nmask(1234567890, -4, '$'); // '$$$$567890'","// isBoolean\n// 지정된 인수가 네이티브 불린 요소 일지 어떨지를 판정합니다.\n// \n// typeof를 사용하여 값이 부울 프리미티브로 분류되는지 확인하십시오.\n\nconst isBoolean = val => typeof val === 'boolean';\n\n// 예시\nisBoolean(null); // false\nisBoolean(false); // true","// getURLParameters\n// 현재 URL의 매개 변수를 포함하는 객체를 반환합니다.\n// \n// String.match()를 적절한 정규 표현식과 함께 사용하여 모든 키 - 값 쌍을 가져오고 Array.reduce()를 매핑하여 단일 객체로 결합합니다.\n// location.search를 인수로 전달하여 현재 url에 적용합니다.\n\nconst getURLParameters = url =>\n  (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(\n    (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a),\n    {}\n  );\n\n// 예시\ngetURLParameters('http://url.com/page?name=Adam&surname=Smith'); // {name: 'Adam', surname: 'Smith'}\ngetURLParameters('google.com'); // {}","// isEven\n// 주어진 숫자가 짝수이면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// 숫자가 홀수인지 또는 모듈러스 (%) 연산자를 사용하는지 확인합니다.\n// 숫자가 짝수이면 true를, 홀수이면 false를 반환합니다.\n\nconst isEven = num => num % 2 === 0;\n\n// 예시\nisEven(3); // false","// takeWhile\n// 전달 된 함수가 true를 반환 할 때까지 배열의 요소를 제거합니다. 삭제 된 요소를 돌려줍니다.\n// \n// 함수에서 반환 된 값이 true가 될 때까지 Array.entries ()에 대해 for ... of 루프를 사용하여 배열을 반복합니다.\n// Array.slice()를 사용하여 제거 된 요소를 반환합니다.\n\nconst takeWhile = (arr, func) => {\n  for (const [i, val] of arr.entries()) if (func(val)) return arr.slice(0, i);\n  return arr;\n};\n\n// 예시\ntakeWhile([1, 2, 3, 4], n => n >= 3); // [1, 2]","// findLast\n// 제공된 함수가 true 값을 반환하는 마지막 요소를 반환합니다.\n// \n// Array.filter()를 사용하여 fn이 false 값을 반환하는 요소를 제거하고 Array.pop()을 사용하여 마지막 값을 가져옵니다.\n\nconst findLast = (arr, fn) => arr.filter(fn).pop();\n\n// 예시\nfindLast([1, 2, 3, 4], n => n % 2 === 1); // 3","// arrayToCSV\n// 2D 배열을 쉼표로 구분 된 값 (CSV) 문자열로 변환합니다.\n// \n// Array.map () 및 Array.join (구분 기호)을 사용하여 개별 1D 배열 (행)을 문자열로 결합합니다.\n// Array.join ( '\\ n')을 사용하여 모든 행을 CSV 문자열로 결합하여 각 행을 개행 문자로 분리합니다.\n// 2 번째의 인수 delimiter를 생략 해, 디폴트의 단락 캐릭터 「,」를 사용합니다.\n\nconst arrayToCSV = (arr, delimiter = ',') =>\n  arr.map(v => v.map(x => `\"${x}\"`).join(delimiter)).join('\\n');\n\n// 예시\narrayToCSV([['a', 'b'], ['c', 'd']]); // '\"a\",\"b\"\\n\"c\",\"d\"'\narrayToCSV([['a', 'b'], ['c', 'd']], ';'); // '\"a\";\"b\"\\n\"c\";\"d\"'","// sleep\n// 비동기 함수의 실행을 지연시킵니다.\n// \n// 비동기 함수의 일부를 실행 대기로 놓고 Promise를 반환하여 지연합니다.\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// 예시\nasync function sleepyWork() {\n  console.log(\"I'm going to sleep for 1 second.\");\n  await sleep(1000);\n  console.log('I woke up after 1 second.');\n}","// capitalize\n// 문자열의 첫 글자를 대문자로 바꿉니다.\n// \n// 배열 소멸 및 String.toUpperCase()를 사용하여 첫 번째 문자를 대문자로 ... rest를 사용하여 첫 번째 문자 다음에 문자 배열을 가져온 다음 Array.join ( '')을 사용하여 문자를 다시 문자열로 만듭니다.\n// lowerRest 매개 변수를 생략하여 나머지 문자열을 그대로 유지하거나 true로 설정하여 소문자로 변환하십시오.\n\nconst capitalize = ([first, ...rest], lowerRest = false) =>\n  first.toUpperCase() + (lowerRest ? rest.join('').toLowerCase() : rest.join(''));\n\n// 예시\ncapitalize('fooBar'); // 'FooBar'\ncapitalize('fooBar', true); // 'Foobar'","// stableSort ![advanced](/advanced.svg)\n// 값이 동일 할 때 항목의 초기 색인을 유지하면서 배열의 안정적인 정렬을 수행합니다.\n// 원래 배열을 변경하지 않지만 대신 새로운 배열을 반환합니다.\n// \n// Array.map()을 사용하여 입력 배열의 각 요소를 해당 색인과 쌍으로 만듭니다.\n// Array.sort () 및 비교 함수를 사용하여 비교 된 항목이 동일한 경우 초기 순서를 유지하면서 목록을 정렬합니다.\n// Array.map()을 사용하여 초기 배열 항목으로 다시 변환하십시오.\n\nconst stableSort = (arr, compare) =>\n  arr\n    .map((item, index) => ({ item, index }))\n    .sort((a, b) => compare(a.item, b.item) || a.index - b.index)\n    .map(({ item }) => item);\n\n// 예시\nconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst stable = stableSort(arr, () => 0); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","// palindrome\n// 주어진 문자열이 회귀 색인이면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// String.toLowerCase () 문자열을 변환하고 String.replace()를 사용하여 영숫자가 아닌 문자를 제거합니다.\n// 그런 다음 spread 연산자 (...)를 사용하여 문자열을 개별 문자 Array.reverse (), String.join ( '')로 분리하고 변환되지 않은 원래 문자열과 String.tolowerCase()를 비교합니다.\n\nconst palindrome = str => {\n  const s = str.toLowerCase().replace(/[\\W_]/g, '');\n  return s === [...s].reverse().join('');\n};\n\n// 예시\npalindrome('taco cat'); // true","// call\n// 키와 인수가 주어지면 컨텍스트가 주어질 때 호출하십시오. 주로 구성에 유용합니다.\n// \n// closure를 사용하여 저장된 인수로 저장된 키를 호출하십시오.\n\nconst call = (key, ...args) => context => context[key](...args);\n\n// 예시\nPromise.resolve([1, 2, 3])\n  .then(call('map', x => 2 * x))\n  .then(console.log); //[ 2, 4, 6 ]\nconst map = call.bind(null, 'map');\nPromise.resolve([1, 2, 3])\n  .then(map(x => 2 * x))\n  .then(console.log); //[ 2, 4, 6 ]","// zipWith ![advanced](/advanced.svg)\n// 원래 배열의 위치에 따라 그룹화 된 요소의 배열을 만들고 마지막 값으로 함수를 사용하여 그룹화 된 값의 결합 방법을 지정합니다.\n// \n// 제공된 마지막 인수가 함수인지 확인하십시오.\n// Math.max()를 사용하여 인수에서 가장 긴 배열을 가져옵니다.\n// 해당 길이의 배열을 반환 값으로 만들고 Array.from()을 map 함수와 함께 사용하여 그룹화 된 요소의 배열을 만듭니다.\n// 인수 배열의 길이가 다른 경우 값을 찾을 수없는 경우 undefined가 사용됩니다.\n// 이 함수는 각 그룹 (... 그룹)의 요소로 호출됩니다.\n\nconst zipWith = (...array) => {\n  const fn = typeof array[array.length - 1] === 'function' ? array.pop() : undefined;\n  return Array.from(\n    { length: Math.max(...array.map(a => a.length)) },\n    (_, i) => (fn ? fn(...array.map(a => a[i])) : array.map(a => a[i]))\n  );\n};\n\n// 예시\nzipWith([1, 2], [10, 20], [100, 200], (a, b, c) => a + b + c); // [111,222]\nzipWith(\n  [1, 2, 3],\n  [10, 20],\n  [100, 200],\n  (a, b, c) => (a != null ? a : 'a') + (b != null ? b : 'b') + (c != null ? c : 'c')\n); // [111, 222, '3bc']","// cloneRegExp\n// 정규 표현식을 복제합니다.\n// \n// 지정된 정규식을 복제하려면 새 RegExp (), RegExp.source 및 RegExp.flags를 사용하십시오.\n\nconst cloneRegExp = regExp => new RegExp(regExp.source, regExp.flags);\n\n// 예시\nconst regExp = /lorem ipsum/gi;\nconst regExp2 = cloneRegExp(regExp); // /lorem ipsum/gi","// head\n// 리스트의 선두를 돌려줍니다.\n// \n// arr [0]을 사용하면 전달 된 배열의 첫 번째 요소를 반환 할 수 있습니다.\n\nconst head = arr => arr[0];\n\n// 예시\nhead([1, 2, 3]); // 1","// radsToDegrees\n// 라디안에서 각도로 각도를 변환합니다.\n// \n// 각도를 라디안에서 각도로 변환하려면 수식에 Math.PI와 라디안을 사용하십시오.\n\nconst radsToDegrees = rad => (rad * 180.0) / Math.PI;\n\n// 예시\nradsToDegrees(Math.PI / 2); // 90","// shuffle\n// 배열 값의 순서를 무작위로 추출하여 새로운 배열을 반환합니다.\n// \n// [Fisher-Yates 알고리즘] (https://github.com/chalarangelo/30-seconds-of-code#shuffle)을 사용하여 배열 요소를 재정렬합니다.\n\nconst shuffle = ([...arr]) => {\n  let m = arr.length;\n  while (m) {\n    const i = Math.floor(Math.random() * m--);\n    [arr[m], arr[i]] = [arr[i], arr[m]];\n  }\n  return arr;\n};\n\n// 예시\nconst foo = [1, 2, 3];\nshuffle(foo); // [2,3,1], foo = [1,2,3]","// flatten\n// 지정된 깊이까지 배열을 병합합니다.\n// \n// 재귀를 사용하여 각 깊이 수준마다 깊이를 1 씩 감소시킵니다.\n// Array.reduce () 및 Array.concat()을 사용하여 요소 나 배열을 병합합니다.\n// 기본 케이스, 깊이가 1이면 재귀를 중지합니다.\n// 두 번째 인수 인 depth를 생략하여 깊이 1까지만 병합합니다 (단일 병합).\n\nconst flatten = (arr, depth = 1) =>\n  arr.reduce((a, v) => a.concat(depth > 1 && Array.isArray(v) ? flatten(v, depth - 1) : v), []);\n\n// 예시\nflatten([1, [2], 3, 4]); // [1, 2, 3, 4]\nflatten([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8]","// when\n// 술어 함수에 대해 x 값을 테스트합니다. true 인 경우 fn (x)를 반환합니다. 그렇지 않으면 x를 반환합니다.\n// \n// pred를 기반으로 적절한 값을 반환하는 단일 값 x가 필요한 함수를 반환합니다.\n\nconst when = (pred, whenTrue) => x => (pred(x) ? whenTrue(x) : x);\n\n// 예시\nconst doubleEvenNumbers = when(x => x % 2 === 0, x => x * 2);\ndoubleEvenNumbers(2); // 4\ndoubleEvenNumbers(1); // 1","// clampNumber\n// 경계 값 a 및 b에 의해 지정된 포괄 범위 내에있는 클램프 num.\n// \n// num이 범위 내에 있으면 num을 반환합니다.\n// 그렇지 않으면 범위에서 가장 가까운 숫자를 반환합니다.\n\nconst clampNumber = (num, a, b) => Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));\n\n// 예시\nclampNumber(2, 3, 5); // 3\nclampNumber(1, -1, -5); // -1","// escapeHTML\n// HTML에서 사용하기 위해 문자열을 이스케이프 처리합니다.\n// \n// 콜백 함수를 사용하여 이스케이프해야하는 문자와 일치하는 정규 표현식과 함께 String.replace()를 사용하여 각 문자 인스턴스를 사전 (객체)을 사용하여 연결된 이스케이프 문자로 바꿉니다.\n\nconst escapeHTML = str =>\n  str.replace(\n    /[&<>'\"]/g,\n    tag =>\n      ({\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        \"'\": '&#39;',\n        '\"': '&quot;'\n      }[tag] || tag)\n  );\n\n// 예시\nescapeHTML('<a href=\"#\">Me & you</a>'); // '&lt;a href=&quot;#&quot;&gt;Me &amp; you&lt;/a&gt;'","// binomialCoefficient\n// 두 정수 n과 k의 이항 계수를 계산합니다.\n// \n// Number.isNaN()을 사용하여 두 값 중 하나가 NaN인지 확인합니다.\n// k가 0보다 작거나 같거나 같거나 1 또는 n - 1인지 확인하고 적절한 결과를 반환하십시오.\n// n - k가 k보다 작은 지 확인하고 그에 따라 값을 변경하십시오.\n// 2에서 k까지 반복하고 이항 계수를 계산합니다.\n// 계산에서 반올림 오류를 설명하려면 Math.round()를 사용하십시오.\n\nconst binomialCoefficient = (n, k) => {\n  if (Number.isNaN(n) || Number.isNaN(k)) return NaN;\n  if (k < 0 || k > n) return 0;\n  if (k === 0 || k === n) return 1;\n  if (k === 1 || k === n - 1) return n;\n  if (n - k < k) k = n - k;\n  let res = n;\n  for (let j = 2; j <= k; j++) res *= (n - j + 1) / j;\n  return Math.round(res);\n};\n\n// 예시\nbinomialCoefficient(8, 2); // 28","// atob\n// base-64 인코딩을 사용하여 인코딩 된 일련의 데이터를 디코딩합니다.\n// \n// 주어진 문자열에 대해 Base-64 인코딩을 사용하여 Buffer를 만들고 Buffer.toString ( 'binary')을 사용하여 디코딩 된 문자열을 반환합니다.\n\nconst atob = str => new Buffer(str, 'base64').toString('binary');\n\n// 예시\natob('Zm9vYmFy'); // 'foobar'","// spreadOver\n// variadic 함수를 취하고 함수의 입력에 매핑 할 인수 배열을 허용하는 클로저를 반환합니다.\n// \n// 클로저와 스프레드 연산자 (...)를 사용하여 인수 배열을 함수 입력에 매핑합니다.\n\nconst spreadOver = fn => argsArr => fn(...argsArr);\n\n// 예시\nconst arrayMax = spreadOver(Math.max);\narrayMax([1, 2, 3]); // 3","// stringPermutations\n// ⚠️ ** 경고 ** :이 기능의 실행 시간은 문자마다 기하 급수적으로 증가합니다. 8 ~ 10자를 초과하는 문자는 브라우저가 다른 조합을 모두 풀려고 할 때 멈추게됩니다.\n// \n// 문자열의 모든 순열을 생성합니다 (중복 포함).\n// \n// 재귀를 사용하십시오.\n// 주어진 문자열의 각 문자에 대해 나머지 문자에 대한 모든 부분 순열을 작성하십시오.\n// Array.map()을 사용하여 문자를 각 부분 순열과 결합한 다음 Array.reduce()를 사용하여 모든 순열을 하나의 배열로 결합합니다.\n// 기본 케이스는 문자열 길이가 2 또는 1 인 경우입니다.\n\nconst stringPermutations = str => {\n  if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];\n  return str\n    .split('')\n    .reduce(\n      (acc, letter, i) =>\n        acc.concat(stringPermutations(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)),\n      []\n    );\n};\n\n// 예시\nstringPermutations('abc'); // ['abc','acb','bac','bca','cab','cba']","// toSafeInteger\n// 값을 안전한 정수로 변환합니다.\n// \n// 가장 가까운 안전한 값을 찾으려면 Math.max () 및 Math.min()을 사용하십시오.\n// Math.round()를 사용하여 정수로 변환하십시오.\n\nconst toSafeInteger = num =>\n  Math.round(Math.max(Math.min(num, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER));\n\n// 예시\ntoSafeInteger('3.2'); // 3\ntoSafeInteger(Infinity); // 9007199254740991","// averageBy\n// 제공된 함수를 사용하여 각 요소를 값에 매핑 한 후 배열의 평균을 반환합니다.\n// \n// Array.map()을 사용하여 각 요소를 fn, Array.reduce ()에서 반환 한 값에 매핑하여 각 값을 누적기에 더하고 값 0으로 초기화하여 배열의 길이로 나눕니다.\n\nconst averageBy = (arr, fn) =>\n  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0) /\n  arr.length;\n\n// 예시\naverageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 5\naverageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 5","// get\n// 지정된 셀렉터가 가리키는 프로퍼티 세트를 오브젝트로부터 취득합니다.\n// \n// 각 선택기 인 String.replace()를 사용하여 대괄호를 점으로 교체하고 String.split ( '.')을 사용하여 각 선택기를 분할하고 Array.filter()를 사용하여 빈 값을 제거하고 Array.reduce () 그것에 의해 지시 된 값을 얻는다.\n\nconst get = (from, ...selectors) =>\n  [...selectors].map(s =>\n    s\n      .replace(/\\[([^\\[\\]]*)\\]/g, '.$1.')\n      .split('.')\n      .filter(t => t !== '')\n      .reduce((prev, cur) => prev && prev[cur], from)\n  );\n\n// 예시\nconst obj = { selector: { to: { val: 'val to select' } }, target: [1, 2, { a: 'test' }] };\nget(obj, 'selector.to.val', 'target[0]', 'target[2].a'); // ['val to select', 1, 'test']","// tomorrow\n// 결과는 내일 날짜의 문자열 표현입니다.\n// 새 Date()를 사용하여 오늘 날짜를 가져오고 Date.getDate () 및 Date.setDate()를 사용하여 하루를 추가하고 Date 객체를 문자열로 변환합니다.\n\nconst tomorrow = (long = false) => {\n  let t = new Date();\n  t.setDate(t.getDate() + 1);\n  const ret = `${t.getFullYear()}-${String(t.getMonth() + 1).padStart(2, '0')}-${String(\n    t.getDate()\n  ).padStart(2, '0')}`;\n  return !long ? ret : `${ret}T00:00:00`;\n};\n\n// 예시\ntomorrow(); // 2017-12-27 (if current date is 2017-12-26)\ntomorrow(true); // 2017-12-27T00:00:00 (if current date is 2017-12-26)","// functions\n// 개체의 자체 (및 선택적으로 상속 된) 열거 가능 속성에서 함수 속성 이름의 배열을 반환합니다.\n// \n// Object.keys (obj)를 사용하여 객체의 자체 속성을 반복합니다.\n// inherited가 true 인 경우는, Object.get.PrototypeOf (obj)를 사용해, 오브젝트의 상속 된 property도 취득합니다.\n// 함수 인 속성 만 유지하려면 Array.filter()를 사용하십시오.\n// 기본적으로 상속 된 속성을 포함하지 않도록 두 번째 인수 인 inherited를 생략하십시오.\n\nconst functions = (obj, inherited = false) =>\n  (inherited\n    ? [...Object.keys(obj), ...Object.keys(Object.getPrototypeOf(obj))]\n    : Object.keys(obj)\n  ).filter(key => typeof obj[key] === 'function');\n\n// 예시\nfunction Foo() {\n  this.a = () => 1;\n  this.b = () => 2;\n}\nFoo.prototype.c = () => 3;\nfunctions(new Foo()); // ['a', 'b']\nfunctions(new Foo(), true); // ['a', 'b', 'c']","// any\n// 제공된 조건부 함수가 컬렉션의 적어도 하나의 요소에 대해 true를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// Array.some()을 사용하여 콜렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다.\n// 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오.\n\nconst any = (arr, fn = Boolean) => arr.some(fn);\n\n// 예시\nany([0, 1, 2, 0], x => x >= 2); // true\nany([0, 0, 1, 0]); // true","// similarity\n// 두 배열에 나타나는 요소의 배열을 반환합니다.\n// \n// Array.includes()를 사용하여 결정된 값의 일부가 아닌 값을 제거하려면 Array.filter()를 사용하십시오.\n\nconst similarity = (arr, values) => arr.filter(v => values.includes(v));\n\n// 예시\nsimilarity([1, 2, 3], [1, 2, 4]); // [1,2]","// RGBToHex\n// RGB 구성 요소의 값을 색상 코드로 변환합니다.\n// \n// 비트 왼쪽 시프트 연산자 (<<) 및 toString (16)을 사용하고 String.padStart (6, '0')을 사용하여 지정된 RGB 매개 변수를 16 진수 문자열로 변환하여 6 자리 16 진수 값을 얻습니다.\n\nconst RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n\n// 예시\nRGBToHex(255, 165, 1); // 'ffa501'","// pad\n// 지정된 길이보다 짧은 경우 지정된 문자로 양쪽에 문자열을 덧붙입니다.\n// \n// String.padStart () 및 String.padEnd()를 사용하여 지정된 문자열의 양쪽을 채 웁니다.\n// 공백 문자를 기본 패딩 문자로 사용하려면 세 번째 인수 인 char을 생략하십시오.\n\nconst pad = (str, length, char = ' ') =>\n  str.padStart((str.length + length) / 2, char).padEnd(length, char);\n\n// 예시\npad('cat', 8); // '  cat   '\npad(String(42), 6, '0'); // '004200'\npad('foobar', 3); // 'foobar'","// prefix\n// 브라우저가 지원하는 CSS 프로퍼티의 프리픽스 첨부의 버젼 (필요하면)을 돌려줍니다.\n// \n// vendor.findIndex()를 공급 업체 접두사 배열의 배열에 사용하여 document.body가 해당 CSSStyleDeclaration 객체에 정의되어 있는지 테스트합니다. 그렇지 않으면 null을 반환합니다.\n// String.charAt () 및 String.toUpperCase()를 사용하여 속성을 대문자로 만드십시오.이 속성은 공급 업체 접두사 문자열에 추가됩니다.\n\nconst prefix = prop => {\n  const capitalizedProp = prop.charAt(0).toUpperCase() + prop.slice(1);\n  const prefixes = ['', 'webkit', 'moz', 'ms', 'o'];\n  const i = prefixes.findIndex(\n    prefix => typeof document.body.style[prefix ? prefix + capitalizedProp : prop] !== 'undefined'\n  );\n  return i !== -1 ? (i === 0 ? prop : prefixes[i] + capitalizedProp) : null;\n};\n\n// 예시\nprefix('appearance'); // 'appearance' on a supported browser, otherwise 'webkitAppearance', 'mozAppearance', 'msAppearance' or 'oAppearance'","// bifurcateBy\n// 입력 컬렉션의 요소가 속한 그룹을 지정하는 조건 자 함수에 따라 값을 두 그룹으로 나눕니다. 술어 함수가 truthy 값을 리턴하면 콜렉션 요소는 첫 x 째 그룹에 속합니다. 그렇지 않으면 두 번째 그룹에 속합니다.\n// \n// 각 요소에 대해 fn이 반환 한 값을 기반으로 Array.reduce () 및 Array.push()를 사용하여 그룹에 요소를 추가합니다.\n\nconst bifurcateBy = (arr, fn) =>\n  arr.reduce((acc, val, i) => (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []]);\n\n// 예시\nbifurcateBy(['beep', 'boop', 'foo', 'bar'], x => x[0] === 'b'); // [ ['beep', 'boop', 'bar'], ['foo'] ]","// hasClass\n// 요소에 지정된 클래스가 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// 요소에 지정된 클래스가 있는지 확인하려면 element.classList.contains()를 사용하십시오.\n\nconst hasClass = (el, className) => el.classList.contains(className);\n\n// 예시\nhasClass(document.querySelector('p.special'), 'special'); // true","// groupBy\n// 지정된 함수를 기반으로 배열 요소를 그룹화합니다.\n// \n// Array.map()을 사용하여 배열 값을 함수 또는 속성 이름에 매핑합니다.\n// Array.reduce()를 사용하여 매핑 된 결과에서 키가 생성되는 객체를 만듭니다.\n\nconst groupBy = (arr, fn) =>\n  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val, i) => {\n    acc[val] = (acc[val] || []).concat(arr[i]);\n    return acc;\n  }, {});\n\n// 예시\ngroupBy([6.1, 4.2, 6.3], Math.floor); // {4: [4.2], 6: [6.1, 6.3]}\ngroupBy(['one', 'two', 'three'], 'length'); // {3: ['one', 'two'], 5: ['three']}","// copyToClipboard ![advanced](/advanced.svg)\n// ⚠️ **주의 사항 : ** 새로운 비동기 클립 보드 API를 사용하면 동일한 기능을 쉽게 구현할 수 있습니다.이 API는 실험적이지만이 스 니펫 대신 미래에 사용해야합니다. 자세한 내용은 [여기] (https://github.com/w3c/clipboard-apis/blob/master/explainer.adoc#writing-to-the-clipboard)를 참조하십시오.\n// \n// 클립 보드에 문자열을 복사합니다. 사용자 동작 (즉, 클릭 이벤트 수신기 내부)의 결과로만 작동합니다.\n// \n// 새로운 <textarea> 요소를 만들고 제공된 데이터로 채우고 HTML 문서에 추가하십시오.\n// Selection.getRangeAt()를 사용하여 선택한 범위 (있는 경우)를 저장합니다.\n// document.execCommand ( 'copy')를 사용하여 클립 보드에 복사하십시오.\n// HTML 문서에서 <textarea> 요소를 제거하십시오.\n// 마지막으로 Selection (). addRange()를 사용하여 원래 선택한 범위를 복구합니다 (있는 경우).\n\nconst copyToClipboard = str => {\n  const el = document.createElement('textarea');\n  el.value = str;\n  el.setAttribute('readonly', '');\n  el.style.position = 'absolute';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  const selected =\n    document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;\n  el.select();\n  document.execCommand('copy');\n  document.body.removeChild(el);\n  if (selected) {\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(selected);\n  }\n};\n\n// 예시\ncopyToClipboard('Lorem ipsum'); // 'Lorem ipsum' copied to clipboard.","// minN\n// 제공된 배열에서 n 개의 최소 요소를 리턴합니다. n가 제공된 배열의 길이보다 크거나 같으면 원래 배열을 반환합니다 (오름차순으로 정렬).\n// \n// 분산 연산자 (...)와 결합 된 Array.sort()를 사용하여 배열의 얕은 복제본을 만들고 오름차순으로 정렬합니다.\n// Array.slice()를 사용하여 지정된 수의 요소를 가져옵니다.\n// 두 번째 인수 인 n을 생략하여 단일 요소 배열을 가져옵니다.\n\nconst minN = (arr, n = 1) => [...arr].sort((a, b) => a - b).slice(0, n);\n\n// 예시\nminN([1, 2, 3]); // [1]\nminN([1, 2, 3], 2); // [1,2]","// mostPerformant\n// 가장 빨리 실행 한 함수 배열에서 함수의 인덱스를 반환합니다.\n// \n// Array.map()을 사용하여 각 값이 반복 횟수 후에 함수를 실행하는 데 걸리는 총 시간 인 배열을 생성합니다. 전후에 performance.now () 값의 차이를 사용하여 총 시간 (밀리 초)을 높은 정확도로 얻으십시오.\n// Math.min()을 사용하여 최소 실행 시간을 찾고 가장 성능이 좋은 함수의 인덱스에 해당하는 가장 짧은 시간의 인덱스를 반환합니다.\n// 두 번째 인수 iteration을 생략하고 기본값 10,000 반복을 사용합니다. 반복 횟수가 많을수록 결과의 신뢰성은 높아지지만 시간이 오래 걸릴 것입니다.\n\nconst mostPerformant = (fns, iterations = 10000) => {\n  const times = fns.map(fn => {\n    const before = performance.now();\n    for (let i = 0; i < iterations; i++) fn();\n    return performance.now() - before;\n  });\n  return times.indexOf(Math.min(...times));\n};\n\n// 예시\nmostPerformant([\n  () => {\n    // Loops through the entire array before returning `false`\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, '10'].every(el => typeof el === 'number');\n  },\n  () => {\n    // Only needs to reach index `1` before returning false\n    [1, '2', 3, 4, 5, 6, 7, 8, 9, 10].every(el => typeof el === 'number');\n  }\n]); // 1","// chunk\n// 배열을 지정된 크기의 더 작은 배열로 채 웁니다.\n// \n// Array.from()을 사용하여 생성 될 청크의 수에 맞는 새 배열을 만듭니다.\n// Array.slice()를 사용하여 새 배열의 각 요소를 청크에 크기의 길이로 매핑합니다.\n// 원래 배열을 균등하게 분할 할 수없는 경우 최종 청크에는 나머지 요소가 포함됩니다.\n\nconst chunk = (arr, size) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>\n    arr.slice(i * size, i * size + size)\n  );\n\n// 예시\nchunk([1, 2, 3, 4, 5], 2); // [[1,2],[3,4],[5]]","// factorial\n// 숫자의 계승을 계산합니다.\n// \n// 재귀를 사용하십시오.\n// n이 1보다 작거나 같으면 1을 반환합니다.\n// 그렇지 않으면, n과 n - 1의 팩토리얼의 곱을 리턴한다.\n// n가 음수이면 예외를 던집니다.\n\nconst factorial = n =>\n  n < 0\n    ? (() => {\n        throw new TypeError('Negative numbers are not allowed!');\n      })()\n    : n <= 1\n      ? 1\n      : n * factorial(n - 1);\n\n// 예시\nfactorial(6); // 720","// isSorted\n// 배열이 오름차순으로 정렬되면 1을, 내림차순으로 정렬되면 -1을 반환하고 정렬되지 않은 경우 0을 반환합니다.\n// \n// 처음 두 요소의 순서 방향을 계산하십시오.\n// Object.entries()를 사용하여 배열 객체를 반복하고 쌍으로 비교합니다.\n// 방향이 바뀌면 0을 반환하고 마지막 요소에 도달하면 방향을 반환합니다.\n\nconst isSorted = arr => {\n  let direction = -(arr[0] - arr[1]);\n  for (let [i, val] of arr.entries()) {\n    direction = !direction ? -(arr[i - 1] - arr[i]) : direction;\n    if (i === arr.length - 1) return !direction ? 0 : direction;\n    else if ((val - arr[i + 1]) * direction > 0) return 0;\n  }\n};\n\n// 예시\nisSorted([0, 1, 2, 2]); // 1\nisSorted([4, 3, 2]); // -1\nisSorted([4, 3, 5]); // 0","// take\n// n 요소가 처음부터 제거 된 배열을 반환합니다.\n// \n// Array.slice()를 사용하여 처음부터 n 개의 요소가있는 배열의 조각을 만듭니다.\n\nconst take = (arr, n = 1) => arr.slice(0, n);\n\n// 예시\ntake([1, 2, 3], 5); // [1, 2, 3]\ntake([1, 2, 3], 0); // []","// unionWith\n// 제공된 비교 함수를 사용하여 두 배열 중 하나에있는 모든 요소를 한 번 반환합니다.\n// \n// Array.findIndex()를 사용해, Comparator가 a에 일치하는 것을 발견하지 않았던 b에 모든 a 및 values의 값을 가지는 Set를 작성합니다.\n\nconst unionWith = (a, b, comp) =>\n  Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comp(x, y)) === -1)]));\n\n// 예시\nunionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2, 1.5, 3, 0, 3.9]","// attempt\n// 제공된 인수를 사용하여 함수를 호출하고 결과 또는 catch 된 오류 객체를 반환하려고 시도합니다.\n// \n// try ... catch 블록을 사용하여 함수의 결과 또는 적절한 오류를 반환하십시오.\n\nconst attempt = (fn, ...args) => {\n  try {\n    return fn(...args);\n  } catch (e) {\n    return e instanceof Error ? e : new Error(e);\n  }\n};\n\n// 예시\nvar elements = attempt(function(selector) {\n  return document.querySelectorAll(selector);\n}, '>_>');\nif (elements instanceof Error) elements = []; // elements = []","// isTravisCI\n// 현재 환경이 [Travis CI] (https://travis-ci.org/)인지 확인합니다.\n// \n// 현재 환경에 TRAVIS 및 CI 환경 변수 ([참조] (https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables))가 있는지 확인합니다.\n\nconst isTravisCI = () => 'TRAVIS' in process.env && 'CI' in process.env;\n\n// 예시\nisTravisCI(); // true (if code is running on Travis CI)","// collectInto\n// 배열을 가변 함수로 받아들이는 함수를 변경합니다.\n// \n// 함수가 주어지면 모든 입력을 수집하는 클로저를 배열 수용 함수로 반환합니다.\n\nconst collectInto = fn => (...args) => fn(args);\n\n// 예시\nconst Pall = collectInto(Promise.all.bind(Promise));\nlet p1 = Promise.resolve(1);\nlet p2 = Promise.resolve(2);\nlet p3 = new Promise(resolve => setTimeout(resolve, 2000, 3));\nPall(p1, p2, p3).then(console.log); // [1, 2, 3] (after about 2 seconds)","// isBrowser\n// 프런트 엔드 모듈이 오류를 발생시키지 않고 서버 (노드)에서 실행될 수 있도록 현재 런타임 환경이 브라우저인지 확인합니다.\n// \n// Array.includes ()는 window 및 document (일반적으로 명시 적으로 정의되지 않은 한 브라우저 환경에서만 사용할 수있는 전역)의 typeof 값에 사용합니다.이 중 하나가 정의되지 않은 경우 true를 반환합니다.\n// typeof는 ReferenceError를 던지지 않고 전역을 검사 할 수있게합니다.\n// 둘 다 정의되지 않은 경우 현재 환경은 브라우저로 간주됩니다.\n\nconst isBrowser = () => ![typeof window, typeof document].includes('undefined');\n\n// 예시\nisBrowser(); // true (browser)\nisBrowser(); // false (Node)","// bifurcate\n// 값을 두 그룹으로 나눕니다. 필터의 요소가 truey이면 컬렉션의 해당 요소가 첫 번째 그룹에 속합니다. 그렇지 않으면 두 번째 그룹에 속합니다.\n// \n// Array.reduce () 및 Array.push()를 사용하여 필터를 기반으로 그룹에 요소를 추가합니다.\n\nconst bifurcate = (arr, filter) =>\n  arr.reduce((acc, val, i) => (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]);\n\n// 예시\nbifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true]); // [ ['beep', 'boop', 'bar'], ['foo'] ]","// nthElement\n// 배열의 n 번째 요소를 반환합니다.\n// \n// Array.slice()를 사용하여 첫 번째 위치에서 n 번째 요소를 포함하는 배열을 가져옵니다.\n// 색인이 범위를 벗어난 경우 []를 반환하십시오.\n// 두 번째 인수 인 n을 생략하여 배열의 첫 번째 요소를 가져옵니다.\n\nconst nthElement = (arr, n = 0) => (n > 0 ? arr.slice(n, n + 1) : arr.slice(n))[0];\n\n// 예시\nnthElement(['a', 'b', 'c'], 1); // 'b'\nnthElement(['a', 'b', 'b'], -3); // 'a'","// toCurrency\n// 숫자를 가져 와서 지정된 통화 서식을 반환하십시오.\n// \n// Intl.NumberFormat을 사용하여 국가 / 통화 구분 서식을 사용합니다.\n\nconst toCurrency = (n, curr, LanguageFormat = undefined) =>\n  Intl.NumberFormat(LanguageFormat, { style: 'currency', currency: curr }).format(n);\n\n// 예시\ntoCurrency(123456.789, 'EUR'); // €123,456.79  | currency: Euro | currencyLangFormat: Local\ntoCurrency(123456.789, 'USD', 'en-us'); // $123,456.79  | currency: US Dollar | currencyLangFormat: English (United States)\ntoCurrency(123456.789, 'USD', 'fa'); // ۱۲۳٬۴۵۶٫۷۹ ؜$ | currency: US Dollar | currencyLangFormat: Farsi\ntoCurrency(322342436423.2435, 'JPY'); // ¥322,342,436,423 | currency: Japanese Yen | currencyLangFormat: Local\ntoCurrency(322342436423.2435, 'JPY', 'fi'); // 322 342 436 423 ¥ | currency: Japanese Yen | currencyLangFormat: Finnish","// is\n// 지정된 값이 지정된 유형인지 확인합니다.\n// \n// Array.includes()를 사용하여 값이 정의되지 않았거나 null이 아니 었는지 확인하고 값의 constructor 속성을 type과 비교하여 제공된 값이 지정된 유형인지 확인합니다.\n\nconst is = (type, val) => ![, null].includes(val) && val.constructor === type;\n\n// 예시\nis(Array, [1]); // true\nis(ArrayBuffer, new ArrayBuffer()); // true\nis(Map, new Map()); // true\nis(RegExp, /./g); // true\nis(Set, new Set()); // true\nis(WeakMap, new WeakMap()); // true\nis(WeakSet, new WeakSet()); // true\nis(String, ''); // true\nis(String, new String('')); // true\nis(Number, 1); // true\nis(Number, new Number(1)); // true\nis(Boolean, true); // true\nis(Boolean, new Boolean(true)); // true","// smoothScroll\n// 호출 된 요소를 브라우저 윈도우의 보이는 영역으로 부드럽게 스크롤합니다.\n// \n// .scrollIntoView 메서드를 사용하여 요소를 스크롤합니다.\n// .scrollIntoView에 {behavior : 'smooth'}를 전달하여 부드럽게 스크롤합니다.\n\nconst smoothScroll = element =>\n  document.querySelector(element).scrollIntoView({\n    behavior: 'smooth'\n  });\n\n// 예시\nsmoothScroll('#fooBar'); // scrolls smoothly to the element with the id fooBar\nsmoothScroll('.fooBar'); // scrolls smoothly to the first element with a class of fooBar","// invertKeyValues\n// 오브젝트의 키 - 값 쌍을 변경하지 않고 반전시킵니다. 각 반전 된 키의 대응하는 반전 된 값은 반전 된 값을 생성하는 책임이있는 키의 배열이다. 함수가 제공되면 각 반전 된 키에 적용됩니다.\n// \n// Object.keys () 및 Array.reduce()를 사용하여 객체의 키 - 값 쌍을 반전하고 제공된 함수 (있는 경우)를 적용합니다.\n// 두 번째 인수 인 fn을 생략하여 반전 된 키를 함수에 적용하지 않고 가져옵니다.\n\nconst invertKeyValues = (obj, fn) =>\n  Object.keys(obj).reduce((acc, key) => {\n    const val = fn ? fn(obj[key]) : obj[key];\n    acc[val] = acc[val] || [];\n    acc[val].push(key);\n    return acc;\n  }, {});\n\n// 예시\ninvertKeyValues({ a: 1, b: 2, c: 1 }); // { 1: [ 'a', 'c' ], 2: [ 'b' ] }\ninvertKeyValues({ a: 1, b: 2, c: 1 }, value => 'group' + value); // { group1: [ 'a', 'c' ], group2: [ 'b' ] }","// findLastKey\n// 제공된 테스트 함수를 만족하는 마지막 키를 리턴합니다. 그렇지 않으면 undefined가 리턴됩니다.\n// \n// Object.keys (obj)를 사용하여 객체의 모든 속성을 가져오고 Array.reverse ()는 순서를 반대로하고 Array.find ()는 각 키 - 값 쌍에 대해 제공된 함수를 테스트합니다. 콜백은 값, 키 및 객체의 세 가지 인수를받습니다.\n\nconst findLastKey = (obj, fn) =>\n  Object.keys(obj)\n    .reverse()\n    .find(key => fn(obj[key], key, obj));\n\n// 예시\nfindLastKey(\n  {\n    barney: { age: 36, active: true },\n    fred: { age: 40, active: false },\n    pebbles: { age: 1, active: true }\n  },\n  o => o['active']\n); // 'pebbles'","// uniqueElementsBy\n// 제공된 비교 함수를 기반으로 배열의 모든 고유 값을 반환합니다.\n// \n// 비교 함수 fn에 따라 각 값의 첫 번째 고유 발생 만 포함하는 배열에 대해 Array.reduce () 및 Array.some()을 사용합니다.\n// 비교 함수는 두 개의 인수, 즉 비교되는 두 요소의 값을 취합니다.\n\nconst uniqueElementsBy = (arr, fn) =>\n  arr.reduce((acc, v) => {\n    if (!acc.some(x => fn(v, x))) acc.push(v);\n    return acc;\n  }, []);\n\n// 예시\nuniqueElementsBy(\n  [\n    { id: 0, value: 'a' },\n    { id: 1, value: 'b' },\n    { id: 2, value: 'c' },\n    { id: 1, value: 'd' },\n    { id: 0, value: 'e' }\n  ],\n  (a, b) => a.id == b.id\n); // [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' } ]","// truncateString\n// 지정된 길이까지 문자열을 자릅니다.\n// \n// 문자열의 길이가 num보다 큰지 확인하십시오.\n// 끝나 원래 문자열에 '...'이 추가 된 상태에서 원하는 길이로 잘린 문자열을 반환합니다.\n\nconst truncateString = (str, num) =>\n  str.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;\n\n// 예시\ntruncateString('boomerang', 7); // 'boom...'","// zipObject\n// 유효한 속성 식별자의 배열과 값의 배열이 주어지면 속성에 값을 연결하는 객체를 반환합니다.\n// \n// 객체는 정의되지 않은 값을 가질 수 있지만 정의되지 않은 속성 포인터는 가질 수 없으므로 Array.reduce()를 사용하여 결과 객체의 구조를 결정하는 데 속성의 배열이 사용됩니다.\n\nconst zipObject = (props, values) =>\n  props.reduce((obj, prop, index) => ((obj[prop] = values[index]), obj), {});\n\n// 예시\nzipObject(['a', 'b', 'c'], [1, 2]); // {a: 1, b: 2, c: undefined}\nzipObject(['a', 'b'], [1, 2, 3]); // {a: 1, b: 2}","// bottomVisible\n// 페이지의 하단이 보이면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n// \n// scrollY, scrollHeight 및 clientHeight를 사용하여 페이지의 맨 아래를 볼 수 있는지 확인합니다.\n\nconst bottomVisible = () =>\n  document.documentElement.clientHeight + window.scrollY >=\n  (document.documentElement.scrollHeight || document.documentElement.clientHeight);\n\n// 예시\nbottomVisible(); // true","// isPromiseLike\n// 객체가 [Promise] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)처럼 보이면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n// \n// 객체가 null이 아니고 typeof가 객체 또는 함수와 일치하는지 여부와 함수가있는 .then 속성이 있는지 확인하십시오.\n\nconst isPromiseLike = obj =>\n  obj !== null &&\n  (typeof obj === 'object' || typeof obj === 'function') &&\n  typeof obj.then === 'function';\n\n// 예시\nisPromiseLike({\n  then: function() {\n    return '';\n  }\n}); // true\nisPromiseLike(null); // false\nisPromiseLike({}); // false","// show\n// 지정된 모든 요소를 표시합니다.\n// \n// 지정된 각 요소의 표시 속성을 지우려면 spread 연산자 (...)와 Array.forEach()를 사용하십시오.\n\nconst show = (...el) => [...el].forEach(e => (e.style.display = ''));\n\n// 예시\nshow(...document.querySelectorAll('img')); // Shows all <img> elements on the page","// unflattenObject ![advanced](/advanced.svg)\n// 키의 패스로 오브젝트의 평탄화를 해제합니다.\n// \n// Array.reduce ()와 결합 된 Object.keys (obj)를 사용하여 병합 경로 노드를 리프 노드로 변환합니다.\n// 키의 값에 도트 구분 기호 (.)가 있으면 Array.split ( '.'), 문자열 변환 및 JSON.parse()를 사용하여 객체를 만든 다음 Object.assign()을 사용하여 리프 노드를 만듭니다.\n// 그렇지 않은 경우 적절한 키 - 값 쌍을 누적 기 오브젝트에 추가하십시오.\n\nconst unflattenObject = obj =>\n  Object.keys(obj).reduce((acc, k) => {\n    if (k.indexOf('.') !== -1) {\n      const keys = k.split('.');\n      Object.assign(\n        acc,\n        JSON.parse(\n          '{' +\n            keys.map((v, i) => (i !== keys.length - 1 ? `\"${v}\":{` : `\"${v}\":`)).join('') +\n            obj[k] +\n            '}'.repeat(keys.length)\n        )\n      );\n    } else acc[k] = obj[k];\n    return acc;\n  }, {});\n\n// 예시\nunflattenObject({ 'a.b.c': 1, d: 1 }); // { a: { b: { c: 1 } }, d: 1 }","// difference\n// 2 개의 배열의 차이를 돌려줍니다.\n// \n// b에서 Set을 만든 다음 a에 Array.filter()를 사용하여 b에 포함되지 않은 값만 유지합니다.\n\nconst difference = (a, b) => {\n  const s = new Set(b);\n  return a.filter(x => !s.has(x));\n};\n\n// 예시\ndifference([1, 2, 3], [1, 2, 4]); // [3]","// compose\n// 오른쪽에서 왼쪽으로 함수를 구성합니다.\n// \n// Array.reduce()를 사용하여 오른쪽에서 왼쪽으로 함수를 구성 할 수 있습니다.\n// 마지막 (가장 오른쪽) 함수는 하나 이상의 인수를 허용 할 수 있습니다. 나머지 함수는 단항이어야합니다.\n\nconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n\n// 예시\nconst add5 = x => x + 5;\nconst multiply = (x, y) => x * y;\nconst multiplyAndAdd5 = compose(\n  add5,\n  multiply\n);\nmultiplyAndAdd5(5, 2); // 15","// CSVToArray\n// 쉼표로 구분 된 값 (CSV) 문자열을 2D 배열로 변환합니다.\n// \n// omitFirstRow가 true 인 경우 Array.slice () 및 Array.indexOf ( '\\ n')를 사용하여 첫 번째 행 (제목 행)을 제거하십시오.\n// String.split ( '\\ n')을 사용하여 각 행의 문자열을 만든 다음 String.split (구분 기호)을 사용하여 각 행의 값을 구분합니다.\n// 2 번째의 인수 delimiter를 생략 해, 디폴트의 단락 캐릭터 「,」를 사용합니다.\n// 세 번째 인수 인 omitFirstRow를 생략하여 CSV 문자열의 첫 번째 행 (제목 행)을 포함시킵니다.\n\nconst CSVToArray = (data, delimiter = ',', omitFirstRow = false) =>\n  data\n    .slice(omitFirstRow ? data.indexOf('\\n') + 1 : 0)\n    .split('\\n')\n    .map(v => v.split(delimiter));\n\n// 예시\nCSVToArray('a,b\\nc,d'); // [['a','b'],['c','d']];\nCSVToArray('a;b\\nc;d', ';'); // [['a','b'],['c','d']];\nCSVToArray('col1,col2\\na,b\\nc,d', ',', true); // [['a','b'],['c','d']];","// toggleClass\n// 요소의 클래스를 토글합니다.\n// \n// 요소에 대해 지정된 클래스를 토글하려면 element.classList.toggle()을 사용하십시오.\n\nconst toggleClass = (el, className) => el.classList.toggle(className);\n\n// 예시\ntoggleClass(document.querySelector('p.special'), 'special'); // The paragraph will not have the 'special' class anymore","// triggerEvent\n// 지정된 요소에서 특정 이벤트를 트리거하고 선택적으로 사용자 정의 데이터를 전달합니다.\n// \n// 새로운 CustomEvent()를 사용하여 지정된 이벤트 유형 및 세부 사항에서 이벤트를 작성하십시오.\n// el.dispatchEvent()를 사용하여 지정된 요소에서 새로 생성 된 이벤트를 트리거합니다.\n// 트리거 된 이벤트에 사용자 지정 데이터를 전달하지 않으려면 세 번째 인수 인 detail을 생략하십시오.\n\nconst triggerEvent = (el, eventType, detail = undefined) =>\n  el.dispatchEvent(new CustomEvent(eventType, { detail: detail }));\n\n// 예시\ntriggerEvent(document.getElementById('myId'), 'click');\ntriggerEvent(document.getElementById('myId'), 'click', { username: 'bob' });","// deepFlatten\n// Deep은 배열을 평평하게합니다.\n// \n// 재귀를 사용하십시오.\n// 배열을 평평하게하려면 Array.concat ()에 빈 배열 ([])과 스프레드 연산자 (...)를 사용합니다.\n// 배열 인 각 요소를 재귀 적으로 병합합니다.\n\nconst deepFlatten = arr => [].concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v)));\n\n// 예시\ndeepFlatten([1, [2], [[3], 4], 5]); // [1,2,3,4,5]","// degreesToRads\n// 각도를도 단위에서 라디안 단위로 변환합니다.\n// \n// 각도를 라디안으로 변환하려면 Math.PI와 라디안 수식의 차수를 사용하십시오.\n\nconst degreesToRads = deg => (deg * Math.PI) / 180.0;\n\n// 예시\ndegreesToRads(90.0); // ~1.5708","// equals ![advanced](/advanced.svg)\n// 두 값을 동일하게 비교할 수 있도록 두 값을 심층 비교합니다.\n// \n// Date.getTime()을 사용하거나 동일한 값을 가진 비 객체 값 (엄격한 비교) 인 경우 두 값이 동일한 지 확인하십시오.\n// 하나의 값이 null이거나 정의되지 않았거나 프로토 타입이 다른지 확인하십시오.\n// 위의 조건 중 하나라도 충족되지 않으면 Object.keys()를 사용하여 두 값의 키 수가 같은지 확인한 다음 Array.every()를 사용하여 첫 번째 값의 모든 키가 두 번째 키에 있는지 확인하고 if 이 메서드를 재귀 적으로 호출하면 (자) 동등합니다.\n\nconst equals = (a, b) => {\n  if (a === b) return true;\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b;\n  if (a === null || a === undefined || b === null || b === undefined) return false;\n  if (a.prototype !== b.prototype) return false;\n  let keys = Object.keys(a);\n  if (keys.length !== Object.keys(b).length) return false;\n  return keys.every(k => equals(a[k], b[k]));\n};\n\n// 예시\nequals({ a: [2, { e: 3 }], b: [4], c: 'foo' }, { a: [2, { e: 3 }], b: [4], c: 'foo' }); // true","// over\n// 제공된 함수를 호출하고 결과를 리턴하는 함수를 작성합니다.\n// \n// Array.map () 및 Function.apply()를 사용하여 각 함수를 주어진 인수에 적용합니다.\n\nconst over = (...fns) => (...args) => fns.map(fn => fn.apply(null, args));\n\n// 예시\nconst minMax = over(Math.min, Math.max);\nminMax(1, 2, 3, 4, 5); // [1,5]","// pluralize\n// 입력 된 숫자를 기반으로 단어의 단수형 또는 복수형을 반환합니다. 첫 번째 인수가 객체 인 경우 제공된 사전에 단어가 포함되어 있으면 s로 끝나지 않는 단어를 자동 복수화 할 수있는 함수를 반환하여 클로저를 사용합니다.\n// \n// num이 -1 또는 1이면 단어의 단수 형태를 반환합니다. num이 다른 숫자이면 복수형을 반환합니다. 단일 단어 + s의 기본값을 사용하려면 세 번째 인수를 생략하거나 필요한 경우 사용자 정의 복수 단어를 제공하십시오. 첫 번째 인수가 객체 인 경우 제공된 사전을 사용하여 올바른 복수형을 해결할 수있는 함수를 반환하여 클로저를 사용합니다.\n\nconst pluralize = (val, word, plural = word + 's') => {\n  const _pluralize = (num, word, plural = word + 's') =>\n    [1, -1].includes(Number(num)) ? word : plural;\n  if (typeof val === 'object') return (num, word) => _pluralize(num, word, val[word]);\n  return _pluralize(val, word, plural);\n};\n\n// 예시\npluralize(0, 'apple'); // 'apples'\npluralize(1, 'apple'); // 'apple'\npluralize(2, 'apple'); // 'apples'\npluralize(2, 'person', 'people'); // 'people'\n\nconst PLURALS = {\n  person: 'people',\n  radius: 'radii'\n};\nconst autoPluralize = pluralize(PLURALS);\nautoPluralize(2, 'person'); // 'people'","// yesNo\n// 문자열이 y / yes이면 true를 반환하고 문자열이 n / no이면 false를 반환합니다.\n// \n// RegExp.test()를 사용하여 문자열이 y / yes 또는 n / no로 평가되는지 확인하십시오.\n// 두 번째 인수 def를 생략하고 기본 응답을 no로 설정합니다.\n\nconst yesNo = (val, def = false) =>\n  /^(y|yes)$/i.test(val) ? true : /^(n|no)$/i.test(val) ? false : def;\n\n// 예시\nyesNo('Y'); // true\nyesNo('yes'); // true\nyesNo('No'); // false\nyesNo('Foo', true); // true","// CSVToJSON ![advanced](/advanced.svg)\n// 쉼표로 구분 된 값 (CSV) 문자열을 객체의 2D 배열로 변환합니다.\n// 문자열의 첫 번째 행은 제목 행으로 사용됩니다.\n// \n// Array.slice () 및 Array.indexOf ( '\\ n') 및 String.split (구분 기호)를 사용하여 첫 번째 행 (제목 행)을 값으로 분리합니다.\n// String.split ( '\\ n')을 사용하여 각 행의 문자열을 만든 다음 Array.map () 및 String.split (구분 기호)을 사용하여 각 행의 값을 구분합니다.\n// Array.reduce()를 사용하여 제목 행에서 파싱 된 키를 사용하여 각 행의 값에 대한 객체를 만듭니다.\n// 2 번째의 인수 delimiter를 생략 해, 디폴트의 단락 캐릭터 「,」를 사용합니다.\n\nconst CSVToJSON = (data, delimiter = ',') => {\n  const titles = data.slice(0, data.indexOf('\\n')).split(delimiter);\n  return data\n    .slice(data.indexOf('\\n') + 1)\n    .split('\\n')\n    .map(v => {\n      const values = v.split(delimiter);\n      return titles.reduce((obj, title, index) => ((obj[title] = values[index]), obj), {});\n    });\n};\n\n// 예시\nCSVToJSON('col1,col2\\na,b\\nc,d'); // [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];\nCSVToJSON('col1;col2\\na;b\\nc;d', ';'); // [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];","// timeTaken\n// 실행할 함수에 걸리는 시간을 측정합니다.\n// \n// console.time () 및 console.timeEnd()를 사용하여 시작 및 종료 시간의 차이를 측정하여 콜백 실행 시간을 결정합니다.\n\nconst timeTaken = callback => {\n  console.time('timeTaken');\n  const r = callback();\n  console.timeEnd('timeTaken');\n  return r;\n};\n\n// 예시\ntimeTaken(() => Math.pow(2, 10)); // 1024, (logged): timeTaken: 0.02099609375ms","// approximatelyEqual\n// 두 숫자가 서로 거의 같은지 확인합니다.\n// \n// Math.abs()를 사용하여 엡실론과 두 값의 절대 차를 비교하십시오.\n// 세 번째 매개 변수 인 ε을 생략하고 기본값 0.001을 사용하십시오.\n\nconst approximatelyEqual = (v1, v2, epsilon = 0.001) => Math.abs(v1 - v2) < epsilon;\n\n// 예시\napproximatelyEqual(Math.PI / 2.0, 1.5708); // true","// renameKeys\n// 여러 객체 키의 이름을 제공된 값으로 바꿉니다.\n// \n// Array.reduce () 및 spread 연산자 (...)와 함께 Object.keys()를 사용하여 객체의 키를 가져오고 keysMap에 따라 이름을 바꿉니다.\n\nconst renameKeys = (keysMap, obj) =>\n  Object.keys(obj).reduce(\n    (acc, key) => ({\n      ...acc,\n      ...{ [keysMap[key] || key]: obj[key] }\n    }),\n    {}\n  );\n\n// 예시\nconst obj = { name: 'Bobo', job: 'Front-End Master', shoeSize: 100 };\nrenameKeys({ name: 'firstName', job: 'passion' }, obj); // { firstName: 'Bobo', passion: 'Front-End Master', shoeSize: 100 }","// sdbm\n// 입력 문자열을 정수로 해시합니다.\n// \n// String.split ( '') 및 Array.reduce()를 사용하여 비트 시프 팅을 사용하여 입력 문자열의 해시를 만듭니다.\n\nconst sdbm = str => {\n  let arr = str.split('');\n  return arr.reduce(\n    (hashCode, currentVal) =>\n      (hashCode = currentVal.charCodeAt(0) + (hashCode << 6) + (hashCode << 16) - hashCode),\n    0\n  );\n};\n\n// 예시\nsdbm('name'); // -3521204949","// maxN\n// 제공된 배열에서 n 개의 최대 요소를 반환합니다. n가 제공된 배열의 길이보다 크거나 같으면 원래 배열을 내림차순으로 정렬하여 반환합니다.\n// \n// 분산 연산자 (...)와 결합 된 Array.sort()를 사용하여 배열의 얕은 복제본을 만들고 내림차순으로 정렬합니다.\n// Array.slice()를 사용하여 지정된 수의 요소를 가져옵니다.\n// 두 번째 인수 인 n을 생략하여 단일 요소 배열을 가져옵니다.\n\nconst maxN = (arr, n = 1) => [...arr].sort((a, b) => b - a).slice(0, n);\n\n// 예시\nmaxN([1, 2, 3]); // [3]\nmaxN([1, 2, 3], 2); // [3,2]","// filterNonUniqueBy\n// 제공된 비교 함수를 기반으로 배열의 고유하지 않은 값을 필터링합니다.\n// \n// 비교 함수 fn에 따라 고유 한 값만 포함하는 배열의 경우 Array.filter () 및 Array.every()를 사용하십시오.\n// 비교 함수는 비교되는 두 요소의 값과 색인이라는 네 가지 인수를 취합니다.\n\nconst filterNonUniqueBy = (arr, fn) =>\n  arr.filter((v, i) => arr.every((x, j) => (i === j) === fn(v, x, i, j)));\n\n// 예시\nfilterNonUniqueBy(\n  [\n    { id: 0, value: 'a' },\n    { id: 1, value: 'b' },\n    { id: 2, value: 'c' },\n    { id: 1, value: 'd' },\n    { id: 0, value: 'e' }\n  ],\n  (a, b) => a.id == b.id\n); // [ { id: 2, value: 'c' } ]","// symmetricDifferenceWith\n// 제공된 함수를 비교 자로 사용하여 두 배열 간의 대칭 차이를 반환합니다.\n// \n// Array.filter () 및 Array.findIndex()를 사용하여 적절한 값을 찾습니다.\n\nconst symmetricDifferenceWith = (arr, val, comp) => [\n  ...arr.filter(a => val.findIndex(b => comp(a, b)) === -1),\n  ...val.filter(a => arr.findIndex(b => comp(a, b)) === -1)\n];\n\n// 예시\nsymmetricDifferenceWith(\n  [1, 1.2, 1.5, 3, 0],\n  [1.9, 3, 0, 3.9],\n  (a, b) => Math.round(a) === Math.round(b)\n); // [1, 1.2, 3.9]","// throttle\n// 최대 대기 밀리 초마다 한 번만 제공된 함수를 호출하는 스로틀 기능을 만듭니다.\n// \n// 주어진 메소드 fn을 조절하려면 setTimeout () 및 clearTimeout()을 사용하십시오.\n// Function.apply()를 사용하여이 컨텍스트를 함수에 적용하고 필요한 인수를 제공하십시오.\n// Date.now()를 사용하여 조절 기능이 마지막으로 호출 된 시간을 추적하십시오.\n// timeout을 기본값 0ms로 설정하려면 두 번째 인수 인 wait를 생략하십시오.\n\nconst throttle = (fn, wait) => {\n  let inThrottle, lastFn, lastTime;\n  return function() {\n    const context = this,\n      args = arguments;\n    if (!inThrottle) {\n      fn.apply(context, args);\n      lastTime = Date.now();\n      inThrottle = true;\n    } else {\n      clearTimeout(lastFn);\n      lastFn = setTimeout(function() {\n        if (Date.now() - lastTime >= wait) {\n          fn.apply(context, args);\n          lastTime = Date.now();\n        }\n      }, wait - (Date.now() - lastTime));\n    }\n  };\n};\n\n// 예시\nwindow.addEventListener(\n  'resize',\n  throttle(function(evt) {\n    console.log(window.innerWidth);\n    console.log(window.innerHeight);\n  }, 250)\n); // Will log the window dimensions at most every 250ms","// isAnagram\n// 문자열이 다른 문자열의 아나 그램인지 확인합니다 (대소 문자를 구별하며 공백, 구두점 및 특수 문자는 무시함).\n// \n// 적절한 정규 표현식과 함께 String.toLowerCase (), String.replace()를 사용하여 두 문자열에서 불필요한 문자 String.split ( ''), Array.sort () 및 Array.join ( '')을 제거하여 정규화합니다. 표준화 된 형식이 같은지 확인하십시오.\n\nconst isAnagram = (str1, str2) => {\n  const normalize = str =>\n    str\n      .toLowerCase()\n      .replace(/[^a-z0-9]/gi, '')\n      .split('')\n      .sort()\n      .join('');\n  return normalize(str1) === normalize(str2);\n};\n\n// 예시\nisAnagram('iceman', 'cinema'); // true","// formatDuration\n// 지정된 밀리 세컨드의 사람이 읽을 수있는 형식을 리턴합니다.\n// \n// 적절한 값으로 ms를 나눕니다. 일,시, 분, 초 및 밀리 초에 대한 적절한 값을 얻습니다.\n// Array.filter ()와 함께 Object.entries()를 사용하면 0이 아닌 값만 유지할 수 있습니다.\n// Array.map()을 사용하여 각 값에 대한 문자열을 만들고 적절하게 복수화하십시오.\n// String.join ( ',')을 사용하여 값을 문자열로 결합하십시오.\n\nconst formatDuration = ms => {\n  if (ms < 0) ms = -ms;\n  const time = {\n    day: Math.floor(ms / 86400000),\n    hour: Math.floor(ms / 3600000) % 24,\n    minute: Math.floor(ms / 60000) % 60,\n    second: Math.floor(ms / 1000) % 60,\n    millisecond: Math.floor(ms) % 1000\n  };\n  return Object.entries(time)\n    .filter(val => val[1] !== 0)\n    .map(val => val[1] + ' ' + (val[1] !== 1 ? val[0] + 's' : val[0]))\n    .join(', ');\n};\n\n// 예시\nformatDuration(1001); // '1 second, 1 millisecond'\nformatDuration(34325055574); // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds'","// sortedIndexBy\n// 제공된 iterator 함수를 기반으로 정렬 순서를 유지하기 위해 배열에 값을 삽입해야하는 가장 낮은 인덱스를 반환합니다.\n// \n// 배열이 내림차순으로 정렬되는지 (느슨하게) 확인하십시오.\n// Array.findIndex()를 사용하여 반복자 함수 fn에 따라 요소가 삽입되어야하는 적절한 인덱스를 찾습니다.\n\nconst sortedIndexBy = (arr, n, fn) => {\n  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);\n  const val = fn(n);\n  const index = arr.findIndex(el => (isDescending ? val >= fn(el) : val <= fn(el)));\n  return index === -1 ? arr.length : index;\n};\n\n// 예시\nsortedIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 0","// uncurry\n// 깊이 n까지 함수의 언커리 (uncurries).\n// \n// variadic 함수를 반환합니다.\n// 제공된 인수에 Array.reduce()를 사용하여 함수의 각 후속 카레 레벨을 호출하십시오.\n// 제공된 인수의 길이가 n보다 작은 경우 오류가 발생합니다.\n// 그렇지 않으면 Array.slice (0, n)를 사용하여 적절한 양의 인수로 fn을 호출합니다.\n// 두 번째 인수 인 n을 생략하여 심도 1까지 언 클레이합니다.\n\nconst uncurry = (fn, n = 1) => (...args) => {\n  const next = acc => args => args.reduce((x, y) => x(y), acc);\n  if (n > args.length) throw new RangeError('Arguments too few!');\n  return next(fn)(args.slice(0, n));\n};\n\n// 예시\nconst add = x => y => z => x + y + z;\nconst uncurriedAdd = uncurry(add, 3);\nuncurriedAdd(1, 2, 3); // 6","// last\n// 배열의 마지막 요소를 반환합니다.\n// \n// arr.length - 1을 사용해, 지정된 배열의 마지막 요소의 인덱스를 계산해, 그것을 돌려줍니다.\n\nconst last = arr => arr[arr.length - 1];\n\n// 예시\nlast([1, 2, 3]); // 3","// xProd\n// 배열로부터 가능한 각 쌍을 작성해, 2 개 (살)의 새로운 배열을 작성합니다.\n// \n// Array.reduce (), Array.map () 및 Array.concat()을 사용하여 두 배열의 요소에서 가능한 모든 쌍을 생성하고 배열에 저장합니다.\n\nconst xProd = (a, b) => a.reduce((acc, x) => acc.concat(b.map(y => [x, y])), []);\n\n// 예시\nxProd([1, 2], ['a', 'b']); // [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]","// capitalizeEveryWord\n// 문자열의 모든 단어의 첫 글자를 대문자로 시작합니다.\n// \n// String.replace()를 사용하여 각 단어의 첫 번째 문자를 일치시키고 String.toUpperCase()를 대문자로 사용하십시오.\n\nconst capitalizeEveryWord = str => str.replace(/\\b[a-z]/g, char => char.toUpperCase());\n\n// 예시\ncapitalizeEveryWord('hello world!'); // 'Hello World!'","// initializeArrayWithRange\n// 시작과 끝이 공통 차이 단계와 함께 포함되는 지정된 범위의 숫자를 포함하는 배열을 초기화합니다.\n// \n// Array.from (Math.ceil ((end + 1-start) / step))을 사용하여 원하는 길이의 배열을 만듭니다 (요소의 양은 (end-start) / step 또는 (end + 1-start ) / end), Array.map ()은 범위에서 원하는 값으로 채 웁니다.\n// start를 생략하면 기본값 0을 사용할 수 있습니다.\n// step을 생략하면 기본값 1을 사용할 수 있습니다.\n\nconst initializeArrayWithRange = (end, start = 0, step = 1) =>\n  Array.from({ length: Math.ceil((end + 1 - start) / step) }).map((v, i) => i * step + start);\n\n// 예시\ninitializeArrayWithRange(5); // [0,1,2,3,4,5]\ninitializeArrayWithRange(7, 3); // [3,4,5,6,7]\ninitializeArrayWithRange(9, 0, 2); // [0,2,4,6,8]","// unescapeHTML\n// 이스케이프 처리 된 HTML 문자를 이스케이프 처리하지 않습니다.\n// \n// 콜백 함수를 사용하여 이스케이프 처리해야하는 문자와 일치하는 정규식과 함께 String.replace()를 사용하여 각 이스케이프 된 문자 인스턴스를 사전 (객체)을 사용하여 연결된 이스케이프 처리되지 않은 문자로 바꿉니다.\n\nconst unescapeHTML = str =>\n  str.replace(\n    /&amp;|&lt;|&gt;|&#39;|&quot;/g,\n    tag =>\n      ({\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&#39;': \"'\",\n        '&quot;': '\"'\n      }[tag] || tag)\n  );\n\n// 예시\nunescapeHTML('&lt;a href=&quot;#&quot;&gt;Me &amp; you&lt;/a&gt;'); // '<a href=\"#\">Me & you</a>'","// defer\n// 현재 호출 스택이 지워질 때까지 함수를 호출합니다.\n// \n// 브라우저 이벤트 큐에 새 이벤트를 추가하고 렌더링 엔진이 작업을 완료하도록하려면 1ms의 시간 초과와 함께 setTimeout()을 사용하십시오. spread (...) 연산자를 사용하여 함수에 임의의 수의 인수를 제공하십시오.\n\nconst defer = (fn, ...args) => setTimeout(fn, 1, ...args);\n\n// 예시\n// Example A:\ndefer(console.log, 'a'), console.log('b'); // logs 'b' then 'a'\n\n// Example B:\ndocument.querySelector('#someElement').innerHTML = 'Hello';\nlongRunningFunction(); //Browser will not update the HTML until this has finished\ndefer(longRunningFunction); // Browser will update the HTML then run the function","// offset\n// 지정된 양의 요소를 배열 끝으로 이동합니다.\n// \n// Array.slice()를 두 번 사용하면 지정된 인덱스 뒤에 요소를 가져오고 그 전에 요소를 가져옵니다.\n// 확산 연산자 (...)를 사용하여 두 연산자를 하나의 배열로 결합합니다.\n// offset이 음수이면 요소는 끝에서 시작으로 이동합니다.\n\nconst offset = (arr, offset) => [...arr.slice(offset), ...arr.slice(0, offset)];\n\n// 예시\noffset([1, 2, 3, 4, 5], 2); // [3, 4, 5, 1, 2]\noffset([1, 2, 3, 4, 5], -2); // [4, 5, 1, 2, 3]","// longestItem\n// 반복 가능한 객체 또는 객체를 길이 속성으로 원하는만큼 가져 와서 가장 긴 객체 또는 객체를 반환합니다.\n// \n// Array.sort()를 사용하여 모든 인수를 길이별로 정렬하고 첫 번째 (가장 긴) 인수를 반환합니다.\n\nconst longestItem = (...vals) => [...vals].sort((a, b) => b.length - a.length)[0];\n\n// 예시\nlongestItem('this', 'is', 'a', 'testcase'); // 'testcase'\nlongestItem(...['a', 'ab', 'abc']); // 'abc'\nlongestItem(...['a', 'ab', 'abc'], 'abcd'); // 'abcd'\nlongestItem([1, 2, 3], [1, 2], [1, 2, 3, 4, 5]); // [1, 2, 3, 4, 5]\nlongestItem([1, 2, 3], 'foobar'); // 'foobar'","// coalesceFactory\n// 제공된 인수 유효성 검증 함수에서 true를 리턴하는 첫 x 째 인수를 리턴하는 사용자 정의 합체 함수를 리턴합니다.\n// \n// Array.find()를 사용하여 제공된 인수 유효성 검사 함수에서 true를 반환하는 첫 번째 인수를 반환합니다.\n\nconst coalesceFactory = valid => (...args) => args.find(valid);\n\n// 예시\nconst customCoalesce = coalesceFactory(_ => ![null, undefined, '', NaN].includes(_));\ncustomCoalesce(undefined, null, NaN, '', 'Waldo'); // \"Waldo\"","// forEachRight\n// 배열의 마지막 요소부터 시작하여 각 배열 요소에 대해 한 번 제공된 함수를 실행합니다.\n// \n// Array.slice (0)를 사용하여 지정된 배열 인 Array.reverse()를 반대로 복사하고 Array.forEach()를 사용하여 반전 된 배열을 반복합니다.\n\nconst forEachRight = (arr, callback) =>\n  arr\n    .slice(0)\n    .reverse()\n    .forEach(callback);\n\n// 예시\nforEachRight([1, 2, 3, 4], val => console.log(val)); // '4', '3', '2', '1'","// isString\n// 지정된 인수가 캐릭터 라인인가 어떤가를 판정합니다.\n// \n// typeof를 사용하여 값이 문자열 프리미티브로 분류되는지 확인하십시오.\n\nconst isString = val => typeof val === 'string';\n\n// 예시\nisString('10'); // true","// once\n// 함수가 한 번만 호출되도록합니다.\n// \n// 클로저를 사용하여, 호출 된 플래그를 사용하고 함수가 처음 호출되면이를 true로 설정하여 다시 호출되지 않도록합니다. 함수가이 컨텍스트를 변경 (예 : 이벤트 리스너에서)되도록하려면 function 키워드를 사용해야하며 제공된 함수에 컨텍스트가 적용되어야합니다.\n// rest / spread (...) 연산자를 사용하여 함수에 임의의 인수를 제공 할 수 있습니다.\n\nconst once = fn => {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    return fn.apply(this, args);\n  };\n};\n\n// 예시\nconst startApp = function(event) {\n  console.log(this, event); // document.body, MouseEvent\n};\ndocument.body.addEventListener('click', once(startApp)); // only runs `startApp` once upon click","// sampleSize\n// 배열에서 배열의 고유 키까지 n 개의 무작위 요소를 가져옵니다.\n// \n// [Fisher-Yates 알고리즘] (https://github.com/chalarangelo/30-seconds-of-code#shuffle)을 사용하여 어레이를 섞습니다.\n// Array.slice()를 사용하여 첫 번째 n 요소를 가져옵니다.\n// 두 번째 인수 인 n을 생략하면 배열에서 무작위로 하나의 요소 만 가져옵니다.\n\nconst sampleSize = ([...arr], n = 1) => {\n  let m = arr.length;\n  while (m) {\n    const i = Math.floor(Math.random() * m--);\n    [arr[m], arr[i]] = [arr[i], arr[m]];\n  }\n  return arr.slice(0, n);\n};\n\n// 예시\nsampleSize([1, 2, 3], 2); // [3,1]\nsampleSize([1, 2, 3], 4); // [2,3,1]","// readFileLines\n// 지정된 파일에서 줄의 배열을 반환합니다.\n// \n// fs 노드 패키지에서 readFileSync 함수를 사용하여 파일에서 버퍼를 작성하십시오.\n// toString (인코딩) 함수를 사용하여 버퍼를 문자열로 변환합니다.\n// 파일 내용을 줄 단위로 분할하여 파일의 내용으로 배열을 만듭니다 (각 \\ n).\n\nconst fs = require('fs');\nconst readFileLines = filename =>\n  fs\n    .readFileSync(filename)\n    .toString('UTF8')\n    .split('\\n');\n\n// 예시\n/*\ncontents of test.txt :\n  line1\n  line2\n  line3\n  ___________________________\n*/\nlet arr = readFileLines('test.txt');\nconsole.log(arr); // ['line1', 'line2', 'line3']","// onUserInputChange ![advanced](/advanced.svg)\n// 사용자 입력 유형이 변경 될 때마다 콜백을 실행하십시오 (마우스 또는 터치). 입력 장치에 따라 코드 활성화 / 비활성화에 유용합니다. 이 프로세스는 동적이며 하이브리드 기기 (예 : 터치 스크린 노트북)에서 작동합니다.\n// \n// 두 개의 이벤트 리스너를 사용하십시오. 처음에는 마우스 입력을 가정하고 터치 스타트 이벤트 리스너를 문서에 바인딩합니다.\n// 터치 시작시 mousemove 이벤트 리스너를 추가하여 performance.now()를 사용하여 20ms 이내에 발생하는 두 개의 연속 mousemove 이벤트를 수신합니다.\n// 이러한 상황에서 인수로 입력 유형을 사용하여 콜백을 실행하십시오.\n\nconst onUserInputChange = callback => {\n  let type = 'mouse',\n    lastTime = 0;\n  const mousemoveHandler = () => {\n    const now = performance.now();\n    if (now - lastTime < 20)\n      (type = 'mouse'), callback(type), document.removeEventListener('mousemove', mousemoveHandler);\n    lastTime = now;\n  };\n  document.addEventListener('touchstart', () => {\n    if (type === 'touch') return;\n    (type = 'touch'), callback(type), document.addEventListener('mousemove', mousemoveHandler);\n  });\n};\n\n// 예시\nonUserInputChange(type => {\n  console.log('The user is now using', type, 'as an input method.');\n});","// toKebabCase\n// 문자열을 케밥 케이스로 변환합니다.\n// \n// 문자열을 단어로 분리하고이를 결합하여 정규 표현식을 사용하여 구분 기호로 추가하십시오.\n\nconst toKebabCase = str =>\n  str &&\n  str\n    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n    .map(x => x.toLowerCase())\n    .join('-');\n\n// 예시\ntoKebabCase('camelCase'); // 'camel-case'\ntoKebabCase('some text'); // 'some-text'\ntoKebabCase('some-mixed_string With spaces_underscores-and-hyphens'); // 'some-mixed-string-with-spaces-underscores-and-hyphens'\ntoKebabCase('AllThe-small Things'); // \"all-the-small-things\"\ntoKebabCase('IAmListeningToFMWhileLoadingDifferentURLOnMyBrowserAndAlsoEditingSomeXMLAndHTML'); // \"i-am-listening-to-fm-while-loading-different-url-on-my-browser-and-also-editing-xml-and-html\"","// omitBy\n// 지정된 함수가 false를 반환하는 속성으로 구성된 객체를 만듭니다. 이 함수는 (value, key) 두 개의 인수로 호출됩니다.\n// \n// Object.keys (obj) 및 Array.filter()를 사용하여 fn이 true 값을 반환하는 키를 제거합니다.\n// Array.reduce()를 사용하여 필터링 된 키를 해당 키 - 값 쌍을 가진 객체로 다시 변환합니다.\n\nconst omitBy = (obj, fn) =>\n  Object.keys(obj)\n    .filter(k => !fn(obj[k], k))\n    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});\n\n// 예시\nomitBy({ a: 1, b: '2', c: 3 }, x => typeof x === 'number'); // { b: '2' }","// isDivisible\n// 첫 번째 숫자 인수가 두 번째 숫자 인수로 나눌 수 있는지 확인합니다.\n// \n// 모듈러스 연산자 (%)를 사용하여 나머지가 0인지 확인하십시오.\n\nconst isDivisible = (dividend, divisor) => dividend % divisor === 0;\n\n// 예시\nisDivisible(6, 3); // true","// toOrdinalSuffix\n// 서수 접미사를 숫자에 추가합니다.\n// \n// 모듈러스 연산자 (%)를 사용하여 한 자리 숫자와 십진수를 찾습니다.\n// 일치하는 서수 패턴 숫자를 찾습니다.\n// 숫자가 십대 패턴으로 발견되면 십대 서문을 사용하십시오.\n\nconst toOrdinalSuffix = num => {\n  const int = parseInt(num),\n    digits = [int % 10, int % 100],\n    ordinals = ['st', 'nd', 'rd', 'th'],\n    oPattern = [1, 2, 3, 4],\n    tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];\n  return oPattern.includes(digits[0]) && !tPattern.includes(digits[1])\n    ? int + ordinals[digits[0] - 1]\n    : int + ordinals[3];\n};\n\n// 예시\ntoOrdinalSuffix('123'); // \"123rd\"","// unary\n// 추가 인수를 무시하고 최대 하나의 인수를 허용하는 함수를 만듭니다.\n// \n// 주어진 첫 번째 인수 만 사용하여 제공된 함수 fn을 호출하십시오.\n\nconst unary = fn => val => fn(val);\n\n// 예시\n['6', '8', '10'].map(unary(parseInt)); // [6, 8, 10]","// isObjectLike\n// 값이 객체와 같은지 확인합니다.\n// \n// 제공된 값이 null이 아니고 typeof가 'object'와 같은지 확인하십시오.\n\nconst isObjectLike = val => val !== null && typeof val === 'object';\n\n// 예시\nisObjectLike({}); // true\nisObjectLike([1, 2, 3]); // true\nisObjectLike(x => x); // false\nisObjectLike(null); // false","// pipeAsyncFunctions\n// 비동기 함수에 대해 왼쪽에서 오른쪽으로 함수를 구성합니다.\n// \n// Promise.then()을 사용하여 왼쪽에서 오른쪽으로 함수를 구성하려면 spread 연산자 (...)와 함께 Array.reduce()를 사용합니다.\n// 이 함수는 간단한 값, Promise의 조합을 반환 할 수 있습니다. 또는 대기중인 값을 반환하는 비동기로 정의 할 수 있습니다.\n// 모든 기능은 단항 적이어야합니다.\n\nconst pipeAsyncFunctions = (...fns) => arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));\n\n// 예시\nconst sum = pipeAsyncFunctions(\n  x => x + 1,\n  x => new Promise(resolve => setTimeout(() => resolve(x + 2), 1000)),\n  x => x + 3,\n  async x => (await x) + 4\n);\n(async () => {\n  console.log(await sum(5)); // 15 (after one second)\n})();","// unzip\n// 배열의 배열을 작성해, [zip] (# zip)에 의해 생성 된 배열에 요소를 그룹 해제합니다.\n// \n// Math.max.apply()를 사용하여 배열에서 가장 긴 하위 배열 인 Array.map()을 사용하여 각 요소를 배열로 만듭니다.\n// Array.reduce () 및 Array.forEach()를 사용하여 그룹화 된 값을 개별 배열에 매핑합니다.\n\nconst unzip = arr =>\n  arr.reduce(\n    (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),\n    Array.from({\n      length: Math.max(...arr.map(x => x.length))\n    }).map(x => [])\n  );\n\n// 예시\nunzip([['a', 1, true], ['b', 2, false]]); //[['a', 'b'], [1, 2], [true, false]]\nunzip([['a', 1, true], ['b', 2]]); //[['a', 'b'], [1, 2], [true]]","// unzipWith ![advanced](/advanced.svg)\n// [zip] (# zip)에 의해 생성 된 배열의 요소를 그룹 해제하고 제공된 함수를 적용하여 요소 배열을 만듭니다.\n// \n// Math.max.apply()를 사용하여 배열에서 가장 긴 하위 배열 인 Array.map()을 사용하여 각 요소를 배열로 만듭니다.\n// Array.reduce () 및 Array.forEach()를 사용하여 그룹화 된 값을 개별 배열에 매핑합니다.\n// Array.map () 및 스프레드 연산자 (...)를 사용하여 요소의 각 개별 그룹에 fn을 적용합니다.\n\nconst unzipWith = (arr, fn) =>\n  arr\n    .reduce(\n      (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),\n      Array.from({\n        length: Math.max(...arr.map(x => x.length))\n      }).map(x => [])\n    )\n    .map(val => fn(...val));\n\n// 예시\nunzipWith([[1, 10, 100], [2, 20, 200]], (...args) => args.reduce((acc, v) => acc + v, 0)); // [3, 30, 300]","// rearg\n// 지정한 인덱스에 따라 정렬 된 인수를 사용하여 제공된 함수를 호출하는 함수를 만듭니다.\n// \n// Array.reduce () 및 Array.indexOf()를 사용하여 스프레드 연산자 (...)와 함께 인덱스를 기반으로 인수를 재정 의하여 변환 된 인수를 fn에 전달합니다.\n\nconst rearg = (fn, indexes) => (...args) =>\n  fn(\n    ...args.reduce(\n      (acc, val, i) => ((acc[indexes.indexOf(i)] = val), acc),\n      Array.from({ length: indexes.length })\n    )\n  );\n\n// 예시\nvar rearged = rearg(\n  function(a, b, c) {\n    return [a, b, c];\n  },\n  [2, 0, 1]\n);\nrearged('b', 'c', 'a'); // ['a', 'b', 'c']","// symmetricDifference\n// 2 개의 배열의 대칭적인 차이를 돌려줍니다.\n// \n// 각 배열에서 집합을 만든 다음 각각에 Array.filter()를 사용하여 다른 배열에 포함되지 않은 값만 유지합니다.\n\nconst symmetricDifference = (a, b) => {\n  const sA = new Set(a),\n    sB = new Set(b);\n  return [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];\n};\n\n// 예시\nsymmetricDifference([1, 2, 3], [1, 2, 4]); // [3,4]","// httpGet\n// 건네받은 URL에 GET 요구를 실시합니다.\n// \n// 주어진 URL에 요청을하려면 [XMLHttpRequest] (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) 웹 API를 사용하십시오.\n// 주어진 콜백 responseText를 호출하여 onload 이벤트를 처리합니다.\n// 제공된 err 함수를 실행하여 onerror 이벤트를 처리하십시오.\n// 세 번째 인수 인 err을 생략하면 기본적으로 콘솔의 오류 스트림에 오류를 기록합니다.\n\nconst httpGet = (url, callback, err = console.error) => {\n  const request = new XMLHttpRequest();\n  request.open('GET', url, true);\n  request.onload = () => callback(request.responseText);\n  request.onerror = () => err(request);\n  request.send();\n};\n\n// 예시\nhttpGet(\n  'https://jsonplaceholder.typicode.com/posts/1',\n  console.log\n); /* \nLogs: {\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n  \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"\n}\n*/","// percentile\n// 백분위 수식을 사용하여 지정된 배열의 숫자가 주어진 값보다 작거나 같은지 계산합니다.\n// \n// Array.reduce()를 사용하여 값 아래의 숫자 수와 동일한 값의 수를 계산하고 백분위 수식을 적용합니다.\n\nconst percentile = (arr, val) =>\n  (100 * arr.reduce((acc, v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0)) / arr.length;\n\n// 예시\npercentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6); // 55","// elementIsVisibleInViewport\n// 지정된 요소가 뷰포트에 표시되면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n// \n// Element.getBoundingClientRect () 및 window.inner (Width | Height) 값을 사용하십시오.\n// 지정된 요소가 뷰포트에 표시되는지 확인합니다.\n// 요소가 완전히 표시되는지 확인하려면 두 번째 인수를 생략하거나 true를 지정하여 if\n// 부분적으로 보입니다.\n\nconst elementIsVisibleInViewport = (el, partiallyVisible = false) => {\n  const { top, left, bottom, right } = el.getBoundingClientRect();\n  const { innerHeight, innerWidth } = window;\n  return partiallyVisible\n    ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&\n        ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))\n    : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\n};\n\n// 예시\n// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}\nelementIsVisibleInViewport(el); // false - (not fully visible)\nelementIsVisibleInViewport(el, true); // true - (partially visible)","// size\n// 배열, 객체 또는 문자열의 크기를 가져옵니다.\n// \n// val의 형태 (배열, 객체 또는 문자열)를 가져옵니다.\n// 배열에 length 속성을 사용합니다.\n// 가능한 경우 길이 또는 크기 값을 사용하거나 객체의 키 수를 사용하십시오.\n// 문자열 용 val에서 생성 된 [Blob 객체] (https://developer.mozilla.org/en-US/docs/Web/API/Blob)의 크기를 사용합니다.\n// \n// 문자열을 split ( '') 문자 배열로 분할하고 길이를 반환합니다.\n\nconst size = val =>\n  Array.isArray(val)\n    ? val.length\n    : val && typeof val === 'object'\n      ? val.size || val.length || Object.keys(val).length\n      : typeof val === 'string'\n        ? new Blob([val]).size\n        : 0;\n\n// 예시\nsize([1, 2, 3, 4, 5]); // 5\nsize('size'); // 4\nsize({ one: 1, two: 2, three: 3 }); // 3","// mapString\n// 호출하는 문자열의 모든 문자에 대해 제공된 함수를 호출 한 결과로 새 문자열을 만듭니다.\n// \n// String.split ( '') 및 Array.map()을 사용하여 str의 각 문자에 대해 제공된 함수 fn을 호출하십시오.\n// Array.join ( '')을 사용하여 문자 배열을 문자열로 재결합합니다.\n// 콜백 함수 fn은 세 개의 인수 (현재 문자, 현재 문자의 색인 및 mapString 문자열이 호출 됨)를 사용합니다.\n\nconst mapString = (str, fn) =>\n  str\n    .split('')\n    .map((c, i) => fn(c, i, str))\n    .join('');\n\n// 예시\nmapString('lorem ipsum', c => c.toUpperCase()); // 'LOREM IPSUM'","// without\n// 지정된 값 중 하나를 갖는 배열의 요소를 필터링합니다.\n// \n// Array.filter()를 사용하여 지정된 모든 값을 제외하고 (! Array.includes()를 사용하여) 배열을 만듭니다.\n// \n// _ (원래 배열을 변형시키는 스 니펫의 경우 [pull] (# pull) 참조) _\n\nconst without = (arr, ...args) => arr.filter(v => !args.includes(v));\n\n// 예시\nwithout([2, 1, 2, 3], 1, 2); // [3]","// powerset\n// 지정된 숫자 배열의 powerset를 리턴합니다.\n// \n// Array.map ()과 결합 된 Array.reduce()를 사용하여 요소를 반복하고 모든 조합을 포함하는 배열로 결합합니다.\n\nconst powerset = arr => arr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);\n\n// 예시\npowerset([1, 2]); // [[], [1], [2], [2,1]]","// lcm\n// 둘 이상의 숫자 중 최소 공배수를 구합니다.\n// \n// 가장 일반적인 공약수 (GCD) 수식과 lcm (x, y) = x * y / gcd (x, y)를 사용하여 최소 공배수를 결정하십시오.\n// GCD 수식은 재귀를 사용합니다.\n\nconst lcm = (...arr) => {\n  const gcd = (x, y) => (!y ? x : gcd(y, x % y));\n  const _lcm = (x, y) => (x * y) / gcd(x, y);\n  return [...arr].reduce((a, b) => _lcm(a, b));\n};\n\n// 예시\nlcm(12, 7); // 84\nlcm(...[1, 3, 4, 5]); // 60","// pullAtValue\n// 원래의 배열을 변경하여 지정된 값을 필터링합니다. 삭제 된 요소를 돌려줍니다.\n// \n// Array.filter () 및 Array.includes()를 사용하여 필요하지 않은 값을 추출합니다.\n// Array.length = 0을 사용하면 길이를 0으로 재설정하고 Array.push()를 사용하여 전달 된 값을 변경하여 끌어온 값만 다시 채 웁니다.\n// pull 된 값을 추적하려면 Array.push()를 사용하십시오.\n\nconst pullAtValue = (arr, pullArr) => {\n  let removed = [],\n    pushToRemove = arr.forEach((v, i) => (pullArr.includes(v) ? removed.push(v) : v)),\n    mutateTo = arr.filter((v, i) => !pullArr.includes(v));\n  arr.length = 0;\n  mutateTo.forEach(v => arr.push(v));\n  return removed;\n};\n\n// 예시\nlet myArray = ['a', 'b', 'c', 'd'];\nlet pulled = pullAtValue(myArray, ['b', 'd']); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]","// distance\n// 두 점 사이의 거리를 반환합니다.\n// \n// 두 점 사이의 유클리드 거리를 계산하려면 Math.hypot()을 사용하십시오.\n\nconst distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);\n\n// 예시\ndistance(1, 1, 2, 3); // 2.23606797749979","// hasFlags\n// 현재 프로세스의 인수에 지정된 플래그가 들어 있는지 확인하십시오.\n// \n// Array.every () 및 Array.includes()를 사용하여 process.argv에 지정된 모든 플래그가 들어 있는지 확인하십시오.\n// 정규 표현식을 사용하여 지정된 플래그 앞에 - 또는 - 접미사가 붙었는지 테스트하고 그에 따라 접두사를 붙입니다.\n\nconst hasFlags = (...flags) =>\n  flags.every(flag => process.argv.includes(/^-{1,2}/.test(flag) ? flag : '--' + flag));\n\n// 예시\n// node myScript.js -s --test --cool=true\nhasFlags('-s'); // true\nhasFlags('--test', 'cool=true', '-s'); // true\nhasFlags('special'); // false","// escapeRegExp\n// 정규 표현에 사용하는 캐릭터 라인을 이스케이프합니다.\n// \n// 특수 문자를 이스케이프하려면 String.replace()를 사용하십시오.\n\nconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n// 예시\nescapeRegExp('(test)'); // \\\\(test\\\\)","// colorize\n// 콘솔에 컬러로 인쇄 할 텍스트에 특수 문자를 추가합니다 (console.log ()와 결합).\n// \n// 템플리트 리터럴과 특수 문자를 사용하여 문자열 출력에 적절한 색상 코드를 추가하십시오.\n// 배경색의 경우, 문자열 끝의 배경색을 재설정하는 특수 문자를 추가하십시오.\n\nconst colorize = (...args) => ({\n  black: `\\x1b[30m${args.join(' ')}`,\n  red: `\\x1b[31m${args.join(' ')}`,\n  green: `\\x1b[32m${args.join(' ')}`,\n  yellow: `\\x1b[33m${args.join(' ')}`,\n  blue: `\\x1b[34m${args.join(' ')}`,\n  magenta: `\\x1b[35m${args.join(' ')}`,\n  cyan: `\\x1b[36m${args.join(' ')}`,\n  white: `\\x1b[37m${args.join(' ')}`,\n  bgBlack: `\\x1b[40m${args.join(' ')}\\x1b[0m`,\n  bgRed: `\\x1b[41m${args.join(' ')}\\x1b[0m`,\n  bgGreen: `\\x1b[42m${args.join(' ')}\\x1b[0m`,\n  bgYellow: `\\x1b[43m${args.join(' ')}\\x1b[0m`,\n  bgBlue: `\\x1b[44m${args.join(' ')}\\x1b[0m`,\n  bgMagenta: `\\x1b[45m${args.join(' ')}\\x1b[0m`,\n  bgCyan: `\\x1b[46m${args.join(' ')}\\x1b[0m`,\n  bgWhite: `\\x1b[47m${args.join(' ')}\\x1b[0m`\n});\n\n// 예시\nconsole.log(colorize('foo').red); // 'foo' (red letters)\nconsole.log(colorize('foo', 'bar').bgBlue); // 'foo bar' (blue background)\nconsole.log(colorize(colorize('foo').yellow, colorize('foo').green).bgWhite); // 'foo bar' (first word in yellow letters, second word in green letters, white background for both)","// unionBy\n// 제공된 함수를 두 배열의 각 배열 요소에 적용한 후 두 배열 중 하나에있는 모든 요소를 한 번만 반환합니다.\n// \n// 모든 fn을 a의 모든 값에 적용하여 집합을 만듭니다.\n// fn을 적용한 후에 값이 이전에 작성된 세트의 값과 일치하지 않는 b의 모든 요소에서 세트를 작성하십시오.\n// 배열로 변환 된 마지막 세트를 리턴합니다.\n\nconst unionBy = (a, b, fn) => {\n  const s = new Set(a.map(v => fn(v)));\n  return Array.from(new Set([...a, ...b.filter(x => !s.has(fn(x)))]));\n};\n\n// 예시\nunionBy([2.1], [1.2, 2.3], Math.floor); // [2.1, 1.2]","// merge\n// 2 개 이상의 객체의 결합으로 새로운 객체를 작성합니다.\n// \n// Object.keys (obj)와 결합 된 Array.reduce()를 사용하여 모든 객체와 키를 반복합니다.\n// hasOwnProperty () 및 Array.concat()을 사용하여 여러 객체에있는 키의 값을 추가합니다.\n\nconst merge = (...objs) =>\n  [...objs].reduce(\n    (acc, obj) =>\n      Object.keys(obj).reduce((a, k) => {\n        acc[k] = acc.hasOwnProperty(k) ? [].concat(acc[k]).concat(obj[k]) : obj[k];\n        return acc;\n      }, {}),\n    {}\n  );\n\n// 예시\nconst object = {\n  a: [{ x: 2 }, { y: 4 }],\n  b: 1\n};\nconst other = {\n  a: { z: 3 },\n  b: [2, 3],\n  c: 'foo'\n};\nmerge(object, other); // { a: [ { x: 2 }, { y: 4 }, { z: 3 } ], b: [ 1, 2, 3 ], c: 'foo' }","// fromCamelCase\n// camelcase에서 문자열을 변환합니다.\n// \n// 밑줄, 하이픈 및 공백을 제거하고 단어를 camelcase로 변환하려면 String.replace()를 사용하십시오.\n// _의 기본 구분 기호를 사용하려면 두 번째 인수를 생략하십시오.\n\nconst fromCamelCase = (str, separator = '_') =>\n  str\n    .replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2')\n    .replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2')\n    .toLowerCase();\n\n// 예시\nfromCamelCase('someDatabaseFieldName', ' '); // 'some database field name'\nfromCamelCase('someLabelThatNeedsToBeCamelized', '-'); // 'some-label-that-needs-to-be-camelized'\nfromCamelCase('someJavascriptProperty', '_'); // 'some_javascript_property'","// primes\n// Eratosthenes의 체를 사용하여 주어진 숫자까지 소수를 생성합니다.\n// \n// 2에서 주어진 숫자로 배열을 생성하십시오. Array.filter()를 사용하여 2에서 임의의 숫자로 나눌 수있는 값을 제공된 숫자의 제곱근으로 필터링합니다.\n\nconst primes = num => {\n  let arr = Array.from({ length: num - 1 }).map((x, i) => i + 2),\n    sqroot = Math.floor(Math.sqrt(num)),\n    numsTillSqroot = Array.from({ length: sqroot - 1 }).map((x, i) => i + 2);\n  numsTillSqroot.forEach(x => (arr = arr.filter(y => y % x !== 0 || y === x)));\n  return arr;\n};\n\n// 예시\nprimes(10); // [2,3,5,7]","// untildify\n// 물결표 경로를 절대 경로로 변환합니다.\n// \n// 정규 표현식 및 OS.homedir ()과 함께 String.replace()를 사용하여 경로 시작 부분의 ~를 홈 디렉토리로 바꿉니다.\n\nconst untildify = str => str.replace(/^~($|\\/|\\\\)/, `${require('os').homedir()}$1`);\n\n// 예시\nuntildify('~/node'); // '/Users/aUser/node'","// promisify\n// 약속을 반환하기 위해 비동기 함수를 변환합니다.\n// \n// currying을 사용하여 원래 함수를 호출하는 Promise를 반환하는 함수를 반환하십시오.\n// ... rest 연산자를 사용하여 모든 매개 변수를 전달하십시오.\n// \n// * 노드 8+에서는 [util.promisify] (https://nodejs.org/api/util.html#util_util_promisify_original) *를 사용할 수 있습니다.\n\nconst promisify = func => (...args) =>\n  new Promise((resolve, reject) =>\n    func(...args, (err, result) => (err ? reject(err) : resolve(result)))\n  );\n\n// 예시\nconst delay = promisify((d, cb) => setTimeout(cb, d));\ndelay(2000).then(() => console.log('Hi!')); // // Promise resolves after 2s","// getColonTimeFromDate\n// Date 객체에서 HH : MM : SS 형식의 문자열을 반환합니다.\n// \n// 주어진 Date 객체의 HH : MM : SS 부분을 가져 오려면 Date.toString () 및 String.slice()를 사용하십시오.\n\nconst getColonTimeFromDate = date => date.toTimeString().slice(0, 8);\n\n// 예시\ngetColonTimeFromDate(new Date()); // \"08:38:00\"","// sumBy\n// 제공된 함수를 사용하여 각 요소를 값에 매핑 한 후 배열의 합을 반환합니다.\n// \n// Array.map()을 사용하여 각 요소를 fn, Array.reduce ()에서 반환 한 값에 매핑하여 누적기에 각 값을 추가하고 값 0으로 초기화합니다.\n\nconst sumBy = (arr, fn) =>\n  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0);\n\n// 예시\nsumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 20\nsumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 20","// httpPost\n// 건네받은 URL에 POST 요구를 실시합니다.\n// \n// 주어진 URL로 게시물 요청을하려면 [XMLHttpRequest] (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) 웹 API를 사용하십시오.\n// setRequestHeader 메소드로 HTTP 요청 헤더의 값을 설정하십시오.\n// 주어진 콜백 responseText를 호출하여 onload 이벤트를 처리합니다.\n// 제공된 err 함수를 실행하여 onerror 이벤트를 처리하십시오.\n// 제공된 url에 데이터를 보내지 않으려면 data라는 세 번째 인수를 생략하십시오.\n// 네 번째 인수 인 err을 생략하면 기본적으로 콘솔의 오류 스트림에 오류를 기록합니다.\n\nconst httpPost = (url, data, callback, err = console.error) => {\n  const request = new XMLHttpRequest();\n  request.open('POST', url, true);\n  request.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n  request.onload = () => callback(request.responseText);\n  request.onerror = () => err(request);\n  request.send(data);\n};\n\n// 예시\nconst newPost = {\n  userId: 1,\n  id: 1337,\n  title: 'Foo',\n  body: 'bar bar bar'\n};\nconst data = JSON.stringify(newPost);\nhttpPost(\n  'https://jsonplaceholder.typicode.com/posts',\n  data,\n  console.log\n); /*\nLogs: {\n  \"userId\": 1,\n  \"id\": 1337,\n  \"title\": \"Foo\",\n  \"body\": \"bar bar bar\"\n}\n*/\nhttpPost(\n  'https://jsonplaceholder.typicode.com/posts',\n  null, //does not send a body\n  console.log\n); /*\nLogs: {\n  \"id\": 101\n}\n*/","// defaults\n// 정의되지 않은 객체의 모든 속성에 기본값을 할당합니다.\n// \n// Object.assign()을 사용하여 빈 객체를 새로 만들고 키 순서를 유지하기 위해 원래 객체를 복사하고 Array.reverse () 및 스프레드 연산자를 사용하여 기본값을 왼쪽에서 오른쪽으로 결합한 다음 마지막으로 obj를 다시 사용합니다. 원래 값이있는 속성을 덮어 씁니다.\n\nconst defaults = (obj, ...defs) => Object.assign({}, obj, ...defs.reverse(), obj);\n\n// 예시\ndefaults({ a: 1 }, { b: 2 }, { b: 6 }, { a: 3 }); // { a: 1, b: 2 }","// pipeFunctions\n// 왼쪽에서 오른쪽으로 기능을 구성합니다.\n// \n// 왼쪽에서 오른쪽으로 함수를 구성하려면 펼치기 연산자 (...)와 함께 Array.reduce()를 사용합니다.\n// 첫 번째 (가장 왼쪽) 함수는 하나 이상의 인수를 허용 할 수 있습니다. 나머지 함수는 단항이어야합니다.\n\nconst pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));\n\n// 예시\nconst add5 = x => x + 5;\nconst multiply = (x, y) => x * y;\nconst multiplyAndAdd5 = pipeFunctions(multiply, add5);\nmultiplyAndAdd5(5, 2); // 15","// reducedFilter\n// 조건에 따라 객체의 배열을 필터링하면서 지정되지 않은 키를 필터링합니다.\n// \n// Array.filter()를 사용하여 조건이 진리 값을 반환 한 객체를 반환하도록 조건부 fn을 기반으로 배열을 필터링합니다.\n// 필터링 된 배열에서 Array.map()을 사용하여 Array.reduce()를 사용하여 새 객체를 반환하여 keys 인수로 제공되지 않은 키를 필터링합니다.\n\nconst reducedFilter = (data, keys, fn) =>\n  data.filter(fn).map(el =>\n    keys.reduce((acc, key) => {\n      acc[key] = el[key];\n      return acc;\n    }, {})\n  );\n\n// 예시\nconst data = [\n  {\n    id: 1,\n    name: 'john',\n    age: 24\n  },\n  {\n    id: 2,\n    name: 'mike',\n    age: 50\n  }\n];\n\nreducedFilter(data, ['id', 'name'], item => item.age > 24); // [{ id: 2, name: 'mike'}]","// countOccurrences\n// 배열에있는 값의 발생을 계산합니다.\n// \n// Array.reduce()를 사용하여 배열 내부의 특정 값을 만날 때마다 카운터를 증가시킵니다.\n\nconst countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);\n\n// 예시\ncountOccurrences([1, 1, 2, 1, 2, 3], 1); // 3","// coalesce\n// 첫 번째 null이 아닌 / 정의되지 않은 인수를 반환합니다.\n// \n// Array.find()를 사용하여 null이 아닌 / 정의되지 않은 첫 번째 인수를 반환합니다.\n\nconst coalesce = (...args) => args.find(_ => ![undefined, null].includes(_));\n\n// 예시\ncoalesce(null, undefined, '', NaN, 'Waldo'); // \"\"","// runAsync ![advanced](/advanced.svg)\n// [Web Worker] (https://developer.mozilla.org/en/USA/docs/Web/API/Web_Workers_API/Using_web_workers)를 사용하여 별도의 스레드에서 함수를 실행하므로 장기 실행 함수가 UI를 차단하지 않습니다.\n// \n// 제공된 함수의 문자열 버전이어야하는 Blob 객체 URL을 사용하여 새 Worker를 만듭니다.\n// 함수 호출의 반환 값을 즉시 반환합니다.\n// 약속을 되풀이하고, 메시지 및 오류 사건을 청취하고 작업자가 게시 한 데이터를 해결하거나 오류를 던집니다.\n\nconst runAsync = fn => {\n  const worker = new Worker(\n    URL.createObjectURL(new Blob([`postMessage((${fn})());`]), {\n      type: 'application/javascript; charset=utf-8'\n    })\n  );\n  return new Promise((res, rej) => {\n    worker.onmessage = ({ data }) => {\n      res(data), worker.terminate();\n    };\n    worker.onerror = err => {\n      rej(err), worker.terminate();\n    };\n  });\n};\n\n// 예시\nconst longRunningFunction = () => {\n  let result = 0;\n  for (let i = 0; i < 1000; i++) {\n    for (let j = 0; j < 700; j++) {\n      for (let k = 0; k < 300; k++) {\n        result = result + i + j + k;\n      }\n    }\n  }\n  return result;\n};\n/*\n  NOTE: Since the function is running in a different context, closures are not supported.\n  The function supplied to `runAsync` gets stringified, so everything becomes literal.\n  All variables and functions must be defined inside.\n*/\nrunAsync(longRunningFunction).then(console.log); // 209685000000\nrunAsync(() => 10 ** 3).then(console.log); // 1000\nlet outsideVariable = 50;\nrunAsync(() => typeof outsideVariable).then(console.log); // 'undefined'","// geometricProgression\n// 시작과 끝이 모두 포함되고 두 단어 사이의 비율이 step 인 지정된 범위의 숫자를 포함하는 배열을 초기화합니다.\n// step = 1 인 경우 오류를 반환합니다.\n// \n// Array.from (), Math.log () 및 Math.floor()를 사용하여 원하는 길이의 배열 인 Array.map()을 만들어 범위의 원하는 값으로 채 웁니다.\n// 두 번째 인수 인 start를 생략하고 기본값 인 1을 사용합니다.\n// 기본 값인 2를 사용하려면 세 번째 인수 인 step을 생략하십시오.\n\nconst geometricProgression = (end, start = 1, step = 2) =>\n  Array.from({ length: Math.floor(Math.log(end / start) / Math.log(step)) + 1 }).map(\n    (v, i) => start * step ** i\n  );\n\n// 예시\ngeometricProgression(256); // [1, 2, 4, 8, 16, 32, 64, 128, 256]\ngeometricProgression(256, 3); // [3, 6, 12, 24, 48, 96, 192]\ngeometricProgression(256, 1, 4); // [1, 4, 16, 64, 256]","// orderBy\n// 프로퍼티와 순서에 의해 순서 붙일 수 있었던 오브젝트의 소트 된 배열을 돌려줍니다.\n// \n// props 배열의 Array.sort (), Array.reduce()를 기본값 0으로 사용하고 배열 소멸을 사용하여 전달 된 순서에 따라 속성 위치를 바꿉니다.\n// 순서 배열이 전달되지 않으면 기본적으로 '오름차순'으로 정렬됩니다.\n\nconst orderBy = (arr, props, orders) =>\n  [...arr].sort((a, b) =>\n    props.reduce((acc, prop, i) => {\n      if (acc === 0) {\n        const [p1, p2] = orders && orders[i] === 'desc' ? [b[prop], a[prop]] : [a[prop], b[prop]];\n        acc = p1 > p2 ? 1 : p1 < p2 ? -1 : 0;\n      }\n      return acc;\n    }, 0)\n  );\n\n// 예시\nconst users = [{ name: 'fred', age: 48 }, { name: 'barney', age: 36 }, { name: 'fred', age: 40 }];\norderBy(users, ['name', 'age'], ['asc', 'desc']); // [{name: 'barney', age: 36}, {name: 'fred', age: 48}, {name: 'fred', age: 40}]\norderBy(users, ['name', 'age']); // [{name: 'barney', age: 36}, {name: 'fred', age: 40}, {name: 'fred', age: 48}]","// compact\n// 배열에서 거짓 값을 제거합니다.\n// \n// 잘못된 값 (false, null, 0, \"\", 정의되지 않음 및 NaN)을 필터링하려면 Array.filter()를 사용하십시오.\n\nconst compact = arr => arr.filter(Boolean);\n\n// 예시\ncompact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]); // [ 1, 2, 3, 'a', 's', 34 ]","// hz\n// 함수가 초당 실행 된 횟수를 반환합니다.\n// hz는 헤르츠 (hertz) 단위이며 주파수 단위는 초당 하나의 주기로 정의됩니다.\n// \n// 반복 반복의 전후에 밀리 초 단위로 차이를 구하려면 performance.now()를 사용하여 함수 반복 실행 시간 경과 시간을 계산합니다.\n// 밀리 초를 초로 변환하고 경과 된 시간으로 나누면 초당 사이클 수를 반환합니다.\n// 두 번째 인수 인 iterations를 생략하고 기본값 100 회 반복을 사용합니다.\n\nconst hz = (fn, iterations = 100) => {\n  const before = performance.now();\n  for (let i = 0; i < iterations; i++) fn();\n  return (1000 * iterations) / (performance.now() - before);\n};\n\n// 예시\n// 10,000 element array\nconst numbers = Array(10000)\n  .fill()\n  .map((_, i) => i);\n\n// Test functions with the same goal: sum up the elements in the array\nconst sumReduce = () => numbers.reduce((acc, n) => acc + n, 0);\nconst sumForLoop = () => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) sum += numbers[i];\n  return sum;\n};\n\n// `sumForLoop` is nearly 10 times faster\nMath.round(hz(sumReduce)); // 572\nMath.round(hz(sumForLoop)); // 4784"]